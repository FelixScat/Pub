<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Cb7d &#39;s blog">
<title>
搞一搞设计模式 - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="搞一搞设计模式"/>
<meta name="twitter:description" content="Design pattern 怎样写出优雅，直观，清晰的代码？这就少不了对设计模式的理解与应用，这篇主要总结归纳一下常见的设计模式和在iOS开发过程中的应用
在这之前，我们需要先回顾一下设计原则
 单一职责原则 (Single Responsibility Principle) 开放-封闭原则 (Open-Closed Principle) 里氏替换原则 (Liskov Substitution Principle) 依赖倒转原则 (Dependence Inversion Principle) 接口隔离原则 (Interface Segregation Principle) 迪米特法则 (Law Of Demeter) 组合/聚合复用原则 (Composite/Aggregate Reuse Principle)  下面是不同设计模式的分类，大致分为三类：
 创建型模式 结构型模式 行为型模式  创建型模式  简单工厂模式 工厂模式 抽象工厂模式 单例模式 建造者模式 原型模式  简单工厂模式 描述：简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
假设你有一个商店，在卖两种产品
protocol Product {} class Product_A: Product {} class Product_B: Product {} class Store { func sellProduct(type: Int) -&gt; Product?"/>

<meta property="og:title" content="搞一搞设计模式" />
<meta property="og:description" content="Design pattern 怎样写出优雅，直观，清晰的代码？这就少不了对设计模式的理解与应用，这篇主要总结归纳一下常见的设计模式和在iOS开发过程中的应用
在这之前，我们需要先回顾一下设计原则
 单一职责原则 (Single Responsibility Principle) 开放-封闭原则 (Open-Closed Principle) 里氏替换原则 (Liskov Substitution Principle) 依赖倒转原则 (Dependence Inversion Principle) 接口隔离原则 (Interface Segregation Principle) 迪米特法则 (Law Of Demeter) 组合/聚合复用原则 (Composite/Aggregate Reuse Principle)  下面是不同设计模式的分类，大致分为三类：
 创建型模式 结构型模式 行为型模式  创建型模式  简单工厂模式 工厂模式 抽象工厂模式 单例模式 建造者模式 原型模式  简单工厂模式 描述：简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
假设你有一个商店，在卖两种产品
protocol Product {} class Product_A: Product {} class Product_B: Product {} class Store { func sellProduct(type: Int) -&gt; Product?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/design-pattern/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2019-03-21T10:46:42+08:00" />
<meta property="article:modified_time" content="2019-03-21T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d &#39;s blog" />


    

    
    
    
    <title>
        
        搞一搞设计模式
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">搞一搞设计模式</div>

        
<div class="section" id="content">
    Thu Mar 21, 2019 &#183; 1904 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        
    </div>
    <hr/>
    <h1 id="design-pattern">Design pattern</h1>
<p>怎样写出优雅，直观，清晰的代码？这就少不了对设计模式的理解与应用，这篇主要总结归纳一下常见的设计模式和在iOS开发过程中的应用</p>
<p>在这之前，我们需要先回顾一下设计原则</p>
<ul>
<li>单一职责原则 (Single Responsibility Principle)</li>
<li>开放-封闭原则 (Open-Closed Principle)</li>
<li>里氏替换原则 (Liskov Substitution Principle)</li>
<li>依赖倒转原则 (Dependence Inversion Principle)</li>
<li>接口隔离原则 (Interface Segregation Principle)</li>
<li>迪米特法则 (Law Of Demeter)</li>
<li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li>
</ul>
<p>下面是不同设计模式的分类，大致分为三类：</p>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">创建型模式</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">结构型模式</a></li>
<li><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型模式</a></li>
</ul>
<h2 id="创建型模式">创建型模式</h2>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">简单工厂模式</a></li>
<li><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">抽象工厂模式</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></li>
<li><a href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">建造者模式</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a></li>
</ul>
<h3 id="简单工厂模式">简单工厂模式</h3>
<p>描述：简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>假设你有一个商店，在卖两种产品</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Product</span> {}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_A</span>: Product {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_B</span>: Product {}


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Store</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct</span>(type: Int) -&gt; Product? {
        <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">0</span> {
            print(<span style="color:#e6db74">&#34;sell Product_A&#34;</span>)
            <span style="color:#66d9ef">return</span> Product_A()
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">1</span> {
            print(<span style="color:#e6db74">&#34;sell Product_B&#34;</span>)
            <span style="color:#66d9ef">return</span> Product_B()
        }
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>;
    }
}
<span style="color:#66d9ef">let</span> store = Store()
Store.sellProduct(type: <span style="color:#ae81ff">0</span>)
Store.sellProduct(type: <span style="color:#ae81ff">1</span>)

</code></pre></div><p>这其实是无工厂模式，直接在方法里面判断最终要卖出的产品，而工厂方法如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">protocol Product {}

<span style="color:#66d9ef">class</span> Product_A: Product {}
<span style="color:#66d9ef">class</span> Product_B: Product {}

<span style="color:#66d9ef">class</span> Factory {
    func sellProduct(type: Int) <span style="color:#f92672">-&gt;</span> Product<span style="color:#f92672">?</span> {
        <span style="color:#66d9ef">if</span> type <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
            print(<span style="color:#e6db74">&#34;sell Product_A&#34;</span>)
            <span style="color:#66d9ef">return</span> Product_A()
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> type <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
            print(<span style="color:#e6db74">&#34;sell Product_B&#34;</span>)
            <span style="color:#66d9ef">return</span> Product_B()
        }
        <span style="color:#66d9ef">return</span> nil;
    }
}

<span style="color:#66d9ef">class</span> Store {
    let factory <span style="color:#f92672">=</span> Factory()
}

let store <span style="color:#f92672">=</span> Store()

store.factory.sellProduct(type: <span style="color:#ae81ff">0</span>)
store.factory.sellProduct(type: <span style="color:#ae81ff">1</span>)
</code></pre></div><p>现在，产品直接由工厂进行接管，我们的店铺不在强依赖产品，只需要提供工厂就好了。</p>
<p>优点：</p>
<ul>
<li>调用者依赖工厂，可以免除对具体产品的直接依赖</li>
<li>调用者无需知道具体产品，直接传递对应的参数即可</li>
</ul>
<p>缺点：</p>
<ul>
<li>工厂集中了产品逻辑，一旦工厂无法正常工作整个系统将会受到影响</li>
<li>添加新产品将修改工厂的逻辑，违反开闭原则</li>
</ul>
<h3 id="工厂模式">工厂模式</h3>
<p>描述：定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Product</span> {}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_A</span>: Product {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_B</span>: Product {}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Factory</span> {
    <span style="color:#75715e">// 工厂类负责定义接口</span>
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct</span>() -&gt; Product? { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct</span>(type: Int) -&gt; Product? {
      	<span style="color:#75715e">// 产品的实例化下放到工厂的子类中进行，有工厂子类负责</span>
        <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">0</span> {
            <span style="color:#66d9ef">return</span> FactoryA().sellProduct()
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">1</span> {
            <span style="color:#66d9ef">return</span> FactoryB().sellProduct()
        }
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FactoryA</span>: Factory {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct</span>() -&gt; Product? {
        print(<span style="color:#e6db74">&#34;sell Product_A&#34;</span>)
        <span style="color:#66d9ef">return</span> Product_A();
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FactoryB</span>: Factory {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct</span>() -&gt; Product? {
        print(<span style="color:#e6db74">&#34;sell Product_B&#34;</span>)
        <span style="color:#66d9ef">return</span> Product_B();
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Store</span> {
    <span style="color:#66d9ef">let</span> factory = Factory()
}

<span style="color:#66d9ef">let</span> store = Store()

store.factory.sellProduct(type: <span style="color:#ae81ff">0</span>)
store.factory.sellProduct(type: <span style="color:#ae81ff">1</span>)
</code></pre></div><p>相较于简单工厂模式，工厂模式定义了工厂的子类用于创建产品。</p>
<p>优点：</p>
<ul>
<li>用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>工厂可以完全自主决定创建产品的细节，实现逻辑由创造哪一种产品变为了选择哪一个共产来生产，职责抽象了出来</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了抽象层会给理解带来一些难度，同时在实现时可能需要使用反射等技术，增加了实现的复杂度</li>
<li>在添加新产品时还需为产品添加新的工厂，增加了复杂度</li>
</ul>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<p>描述：为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。</p>
<p>也即是说，之前我们的工厂对应的产品线是单一的，现在如果我们的工厂扩展了一系列的产品，就需要使用抽象工厂模式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Product</span> {}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_A_1</span>: Product {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_A_2</span>: Product {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_B_1</span>: Product {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product_B_2</span>: Product {}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Factory</span> {
    <span style="color:#75715e">// 贩卖1系列产品</span>
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct1</span>() -&gt; Product? { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }
  	<span style="color:#75715e">// 贩卖2系列产品</span>
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct2</span>() -&gt; Product? { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProductA</span>(type: Int) -&gt; Product? {
        <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">0</span> {
            <span style="color:#66d9ef">return</span> FactoryA().sellProduct1()
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">1</span> {
            <span style="color:#66d9ef">return</span> FactoryA().sellProduct2()
        }
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>;
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProductB</span>(type: Int) -&gt; Product? {
        <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">0</span> {
            <span style="color:#66d9ef">return</span> FactoryB().sellProduct1()
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> type == <span style="color:#ae81ff">1</span> {
            <span style="color:#66d9ef">return</span> FactoryB().sellProduct2()
        }
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FactoryA</span>: Factory {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct1</span>() -&gt; Product? {
        <span style="color:#66d9ef">return</span> Product_A_1()
    }
    
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct2</span>() -&gt; Product? {
        <span style="color:#66d9ef">return</span> Product_A_2()
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FactoryB</span>: Factory {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct1</span>() -&gt; Product? {
        <span style="color:#66d9ef">return</span> Product_B_1()
    }
    
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sellProduct2</span>() -&gt; Product? {
        <span style="color:#66d9ef">return</span> Product_B_1()
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Store</span> {
    <span style="color:#66d9ef">let</span> factory = Factory()
}

<span style="color:#66d9ef">let</span> store = Store()

store.factory.sellProductA(type: <span style="color:#ae81ff">0</span>)
store.factory.sellProductA(type: <span style="color:#ae81ff">1</span>)
store.factory.sellProductB(type: <span style="color:#ae81ff">0</span>)
store.factory.sellProductB(type: <span style="color:#ae81ff">1</span>)
</code></pre></div><p>优点：</p>
<ul>
<li>抽象工厂隔离了对应真实工厂类的生成，这使得更换具体工厂变得相对容易</li>
<li>能够保证调用者只使用同一工厂生产的产品</li>
</ul>
<p>缺点：</p>
<ul>
<li>添加新产品型号时修改将会设计到抽象工厂以及其全部子类，比较麻烦</li>
<li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）</li>
</ul>
<h3 id="单例模式">单例模式</h3>
<p>描述：确保一个类只有一个实例，并提供对该实例的全局访问。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> instance = Singleton()
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">init</span>() {
        
    }
}

<span style="color:#66d9ef">let</span> singleton = Singleton.instance
</code></pre></div><p>这里没什么可多说的，在系统中很多地方都需要全局中使用同一个实例，如 <code>UIApplication.shared</code>，</p>
<p>单例模式的使用有三个要素</p>
<ul>
<li>这个类只能有一个实例</li>
<li>这个实例必须是该类自行创建</li>
<li>它必须自行向整个系统提供该实例</li>
</ul>
<p>优点：</p>
<ul>
<li>提供了共享数据的方法</li>
<li>避免频繁创建销毁所带来的开销</li>
</ul>
<p>缺点：</p>
<ul>
<li>单例对象职责过重，某种程度破坏了单一职责原则</li>
<li>滥用单例会导致在有垃圾自动回收功能的系统中持续占用内存，单例模式应用的数量应该是越少越好</li>
</ul>
<h3 id="建造者模式">建造者模式</h3>
<p>描述：建造者模式（Builder Pattern）也叫做生成器模式，使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Product</span> {
    <span style="color:#66d9ef">var</span> parts: String = <span style="color:#e6db74">&#34;&#34;</span>
}

<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Builder</span> {
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildPart</span>()
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getProduct</span>() -&gt; Product
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Director</span> {
    <span style="color:#66d9ef">let</span> concreteBuilder: Builder
    <span style="color:#66d9ef">init</span>(concreteBuilder: Builder) {
        <span style="color:#66d9ef">self</span>.concreteBuilder = concreteBuilder
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">construct</span>() -&gt;Product{
        concreteBuilder.buildPart()
        <span style="color:#66d9ef">return</span> concreteBuilder.getProduct()
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConcreteBuilder</span>: Builder{
    
    <span style="color:#66d9ef">var</span> product = Product()
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildPart</span>() {
        product.parts = <span style="color:#e6db74">&#34;Finish&#34;</span>
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getProduct</span>() -&gt; Product{
        <span style="color:#66d9ef">return</span> product
    }
}

<span style="color:#66d9ef">let</span> director = Director(concreteBuilder: ConcreteBuilder())
<span style="color:#66d9ef">let</span> product = director.construct()
print(product.parts)
</code></pre></div><p>主要场景为当构建一个复杂的产品的时候，往往产品拥有很多的组成部分，最终用户无须知晓产品构建的具体细节，这时可以使用建造者模式对其进行设计与描述</p>
<p>优点：</p>
<ul>
<li>产品本身与产品的创建过程解耦</li>
<li>方便更换新的建造者，用户可以使用不同的建造者构造新的产品</li>
<li>更加精细的控制产品的创建过程</li>
<li>增加建造者无需修改原类库的代码，方便扩展，符合开闭原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>产品之前差异过大不适用</li>
<li>产品内部变化复杂可能需要增加很多建造者，导致系统变得庞大</li>
</ul>
<h3 id="原型模式">原型模式</h3>
<p>描述：用原型实例指定创建对象的种类，并且通过拷贝这些原型,创建新的对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Prototype</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">clone</span>() -&gt; Prototype
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Product</span>: Prototype {
    <span style="color:#66d9ef">let</span> name: String
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">clone</span>() -&gt; Prototype {
        <span style="color:#66d9ef">return</span> Product(name: name)
    }
}

<span style="color:#66d9ef">let</span> product = Product(name: <span style="color:#e6db74">&#34;apple&#34;</span>)
<span style="color:#66d9ef">let</span> copy = product.clone()
</code></pre></div><p>大多数时候，你可以将原型模式当作深拷贝来理解，用处就是像细胞分裂一样生成大量同样内容的对象</p>
<h2 id="结构型模式">结构型模式</h2>
<ul>
<li><a href="#%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F">模版模式</a></li>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li>
<li><a href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a></li>
<li><a href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">装饰模式</a></li>
<li><a href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">外观模式</a></li>
<li><a href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">享元模式</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a></li>
</ul>
<h3 id="模版模式">模版模式</h3>
<p>描述：模版模式将常见的方法抽象出来，每个成员单独去实现模版中的方法，大多语言的实现可以通过虚基类来实现，在Swift中我们可以使用协议来完成</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Create</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createProduction</span>()
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Factory</span>: Create {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createProduction</span>() {
        print(<span style="color:#e6db74">&#34;all production created&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Worker</span>: Create {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createProduction</span>() {
        print(<span style="color:#e6db74">&#34;product created&#34;</span>)
    }
}

Worker().createProduction()

Factory().createProduction()
</code></pre></div><p>对于<code>createProduction</code>这个方法就是如此，成员只需遵守协议，具体实现内部自己处理</p>
<p>优点：</p>
<ul>
<li>将不变的行为封装起来，避免重复定义</li>
<li>方便更改和扩展具体的实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>抽象容易导致歧义，子类有可能不完全符合模版的方法声明</li>
</ul>
<h3 id="适配器模式">适配器模式</h3>
<p>描述：将一个类的接口转化为使用者希望的接口，适配器模式使得原本无法共同工作的类能够一起工作</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Greeting</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayHI</span>()
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span>: Greeting {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayHI</span>() {
        print(<span style="color:#e6db74">&#34;HI&#34;</span>)
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bark</span>() {
        print(<span style="color:#e6db74">&#34;BarkBark&#34;</span>)
    }
}

<span style="color:#66d9ef">let</span> person1 = Person()
<span style="color:#66d9ef">let</span> person2 = Person()

<span style="color:#66d9ef">let</span> dog1 = Dog()

person1.sayHI()
person2.sayHI()
dog1.bark()
</code></pre></div><p>这时我们希望dog也能使用同样的sayHI方法，这里我们可以使用Swift的extension来完成适配器模式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">let</span> dog1 = Dog()

<span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Dog</span>: Greeting {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sayHI</span>() {
        bark()
    }
}

person1.sayHI()
person2.sayHI()
dog1.sayHI())
</code></pre></div><p>优点：</p>
<ul>
<li>通过适配器重用原方法，无需改动原类</li>
<li>增加了类的透明性和适用性</li>
<li>灵活，可扩展，符合开闭原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于无多继承和extension这种东西的语言实现起来较复杂</li>
</ul>
<h3 id="桥接模式">桥接模式</h3>
<p>描述：将抽象部分与实现部分分离，使之都能独立的变化，又称作接口模式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Action</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">happened</span>()
}

<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Animal</span> {
    <span style="color:#66d9ef">var</span> action: Action? { <span style="color:#66d9ef">get</span> }
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>()
}


<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">People</span>: Animal {
    <span style="color:#66d9ef">var</span> action: Action?
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">walk</span>() {
        print(<span style="color:#e6db74">&#34;Person walk&#34;</span>)
        action?.happened()
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Jump</span>: Action {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">happened</span>() {
        print(<span style="color:#e6db74">&#34;Jump&#34;</span>)
    }
}

<span style="color:#66d9ef">let</span> person = People(action: Jump())
person.walk()
</code></pre></div><p>可以看到，人在走路的时候会发生action，action在内部是抽象的，由外部控制</p>
<p>优点：</p>
<ul>
<li>分离接口抽象以及实现部分</li>
<li>替代多继承的一种解决方案</li>
<li>桥接模式提高了系统的可扩展性</li>
<li>可以对调用方隐藏实现细节</li>
</ul>
<p>缺点：</p>
<ul>
<li>关联关系建立在抽象层，增加了系统的设计难度</li>
</ul>
<h3 id="装饰模式">装饰模式</h3>
<p>描述：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Component</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String
}

<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Decorator</span>: Component {
    <span style="color:#66d9ef">var</span> component: Component { <span style="color:#66d9ef">get</span> }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Coffee</span>: Component {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;making coffee&#34;</span>
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Sugar</span>: Decorator {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String {
        <span style="color:#66d9ef">return</span> component.method() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;add sugar&#34;</span>
    }
    
    <span style="color:#66d9ef">var</span> component: Component
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Milk</span>: Decorator {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String {
        <span style="color:#66d9ef">return</span> component.method() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;add milk&#34;</span>
    }
    
    <span style="color:#66d9ef">var</span> component: Component
}

print(Milk(component: Sugar(component: Coffee())).method())
</code></pre></div><p>这里我们给咖啡加料，在加料有很多的情况下我们使用装饰模式就会很方便，在进行功能扩展的时候比子类化要灵活许多。装饰器模式主要的原理就在于将需要扩展的对象进行包装，并实现与该对象相同的接口，并在将任务传递给被包装的对象之前加入自己的行为。</p>
<p>优点：</p>
<ul>
<li>比子类化的方案要灵活</li>
<li>可以创建多种排列组合</li>
<li>组件类和装饰器类可以独立变化</li>
</ul>
<p>缺点：</p>
<ul>
<li>经过多层装饰的对象在排查错误的时候比较复杂</li>
</ul>
<h3 id="外观模式">外观模式</h3>
<p>描述：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Component</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String
}

<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Decorator</span>: Component {
    <span style="color:#66d9ef">var</span> component: Component { <span style="color:#66d9ef">get</span> }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Coffee</span>: Component {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;making coffee&#34;</span>
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Sugar</span>: Decorator {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String {
        <span style="color:#66d9ef">return</span> component.method() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;add sugar&#34;</span>
    }
    
    <span style="color:#66d9ef">var</span> component: Component
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Milk</span>: Decorator {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">method</span>() -&gt; String {
        <span style="color:#66d9ef">return</span> component.method() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;add milk&#34;</span>
    }
    
    <span style="color:#66d9ef">var</span> component: Component
}

print(Milk(component: Sugar(component: Coffee())).method())

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Store</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">saleCoffee</span>() -&gt; Component {
        <span style="color:#66d9ef">return</span> Milk(component: Sugar(component: Coffee()))
    }
}

Store().saleCoffee().method()
</code></pre></div><p>外观模式主要提供一个接口，外部的使用者去调用接口返回结果而不必关心内部系统的实现，还是以咖啡为例，顾客去购买咖啡只需调用商店的卖出方法，内部如何实现交给子系统</p>
<p>优点：</p>
<ul>
<li>对客户屏蔽内部系统，客户代码将变得简单</li>
<li>实现了松耦合的关系</li>
<li>降低了大型系统中的编译依赖性</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<h3 id="享元模式">享元模式</h3>
<p>描述：享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>这里主要可以参考UITableViewCell的重用机制，Cell的展示会发生变化，但是屏幕上能够展示出来的Cell是有限个的，利用重用机制可以很好的减少内存开销</p>
<p>优点：</p>
<ul>
<li>较少的内存占用</li>
<li>享元对象能够在不同环境中共享</li>
</ul>
<p>缺点：</p>
<ul>
<li>享元对象需要区分内外状态</li>
<li>享元对象的状态外部化会使得读取外部状态的运行时间变长</li>
</ul>
<h3 id="代理模式">代理模式</h3>
<p>描述：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Guarder</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">guardTheEntrance</span>()
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>: Guarder {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">guardTheEntrance</span>() {
        print(<span style="color:#e6db74">&#34;看家中...&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
    
    <span style="color:#66d9ef">var</span> guarder: Guarder
    
    <span style="color:#66d9ef">init</span>(guarder: Guarder) {
        <span style="color:#66d9ef">self</span>.guarder = guarder
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">leaveHome</span>() {
        guarder.guardTheEntrance()
    }
}

Person(guarder: Dog()).leaveHome()
</code></pre></div><p>代理模式就是类本身需要实现某种功能，但是为了降低耦合度本身不去实现，而是委托给其他类去实现</p>
<p>优点：</p>
<ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li>
</ul>
<p>缺点：</p>
<ul>
<li>一定程度上加大了系统的内存开销</li>
</ul>
<h2 id="行为型模式">行为型模式</h2>
<ul>
<li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令模式</a></li>
<li><a href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F">解释器模式</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li>
<li><a href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</a></li>
<li><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F">状态模式</a></li>
<li><a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">备忘录模式</a></li>
<li><a href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a></li>
</ul>
<h3 id="责任链模式">责任链模式</h3>
<p>描述：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Leader</span> {
    
    <span style="color:#66d9ef">var</span> leader: Leader? { <span style="color:#66d9ef">get</span> }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">accept</span>() -&gt; Bool
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Employee</span>: Leader {
    <span style="color:#66d9ef">var</span> leader: Leader?
    
    <span style="color:#66d9ef">init</span>(leader: Leader?) {
        <span style="color:#66d9ef">self</span>.leader = leader
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">accept</span>() -&gt; Bool {
        print(<span style="color:#e6db74">&#34;deal with thing&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span> <span style="color:#f92672">&amp;&amp;</span> leader?.accept() ?? <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#66d9ef">let</span> leader1 = Employee(leader: <span style="color:#66d9ef">nil</span>)
<span style="color:#66d9ef">let</span> leader2 = Employee(leader: leader1)
<span style="color:#66d9ef">let</span> leader3 = Employee(leader: leader2)

leader3.accept()
</code></pre></div><p>比如你要向领导请假，需要一级一级的同意，如上。UIKit的touch事件就应用了责任链模式，使得点击事件能够不断传递。</p>
<p>优点：</p>
<ul>
<li>使得客户端与具体响应者能够松耦合</li>
<li>方便响应者更新响应的方法</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于存在响应链条，处理起来的资源占用可能增加</li>
</ul>
<h3 id="命令模式">命令模式</h3>
<p>描述：将一个请求封装成一个对象，从而使用户可以用不同的请求对客户进行参数化。</p>
<p>命令模式有两个特点：</p>
<ul>
<li>命令逻辑化，命令的逻辑可以由外部传入或内部实现</li>
<li>支持撤销命令（undo）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Command</span> {
    <span style="color:#66d9ef">var</span> operation: () -&gt; Void { <span style="color:#66d9ef">get</span> }
    <span style="color:#66d9ef">var</span> undoOperation: () -&gt; Void { <span style="color:#66d9ef">get</span> }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">WashCommand</span>: Command {
    <span style="color:#66d9ef">var</span> operation: () -&gt; Void
    <span style="color:#66d9ef">var</span> undoOperation: () -&gt; Void
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Person</span> {
    <span style="color:#66d9ef">var</span> command: Command
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">execute</span>() {
        command.operation()
    }
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">undo</span>() {
        command.undoOperation()
    }
}

<span style="color:#66d9ef">let</span> washCommand = WashCommand(operation: {
    print(<span style="color:#e6db74">&#34;wash clothes&#34;</span>)
}) {
    print(<span style="color:#e6db74">&#34;put clothed into sky&#34;</span>)
}

<span style="color:#66d9ef">let</span> person = Person(command: washCommand)

person.execute()

person.undo()
</code></pre></div><p>优点：</p>
<ul>
<li>适合组合命令来实现复杂功能</li>
</ul>
<p>缺点：</p>
<ul>
<li>每个命令都需要具体的类来执行，会创建大量的命令类</li>
</ul>
<h3 id="解释器模式">解释器模式</h3>
<p>描述：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Expression</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">eval</span>(context: String) -&gt; Int
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AddCalculator</span>: Expression {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">eval</span>(context: String) -&gt; Int {
        <span style="color:#66d9ef">return</span> context.components(separatedBy: <span style="color:#e6db74">&#34;+&#34;</span>).compactMap{ Int($0) }.reduce(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">+</span>)
    }
}

AddCalculator().eval(context: <span style="color:#e6db74">&#34;1+1&#34;</span>)
</code></pre></div><p>优点：</p>
<ul>
<li>解释器扩展性强</li>
</ul>
<p>缺点：</p>
<ul>
<li>在解释执行的时候往往会采用递归的形式，效率较低</li>
</ul>
<h3 id="迭代器模式">迭代器模式</h3>
<p>描述：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Product</span> {
    <span style="color:#66d9ef">let</span> id: Int
}

<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Iterator</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hasNext</span>() -&gt; Bool
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">next</span>() -&gt; Product?
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Store</span>: Iterator {
    
    <span style="color:#66d9ef">var</span> products: [Product]
    <span style="color:#66d9ef">var</span> index = <span style="color:#ae81ff">0</span>;
    
    <span style="color:#66d9ef">init</span>(products: [Product]) {
        <span style="color:#66d9ef">self</span>.products = products
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hasNext</span>() -&gt; Bool {
        <span style="color:#66d9ef">return</span> products.count <span style="color:#f92672">&gt;</span> index
    }
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">next</span>() -&gt; Product? {
        <span style="color:#66d9ef">defer</span> {
            index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        }
        
        <span style="color:#66d9ef">return</span> products[index]
    }
}

<span style="color:#66d9ef">let</span> store = Store(products: Array(<span style="color:#ae81ff">1.</span>..<span style="color:#ae81ff">100_</span>).map{ Product(id: $0) })

<span style="color:#66d9ef">while</span> store.hasNext() {
    print(store.next()<span style="color:#f92672">!</span>)
}
</code></pre></div><p>与责任链相比，迭代器更加强调一次完整的遍历，商店只要有货物就会去销售获取，而责任链是随时可以中断的，比较强调响应者的概念</p>
<p>优点：</p>
<ul>
<li>简化了集合的遍历方式</li>
<li>可以为某一个集合提供多种便利方式</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于简单的集合类型来说增加了复杂度</li>
</ul>
<h3 id="中介者模式">中介者模式</h3>
<p>描述：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Colleague</span> {
    <span style="color:#66d9ef">let</span> name: String
    <span style="color:#66d9ef">let</span> mediator: Mediator
    
    <span style="color:#66d9ef">init</span>(name: String, mediator: Mediator) {
        <span style="color:#66d9ef">self</span>.name = name
        <span style="color:#66d9ef">self</span>.mediator = mediator
    }
    
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     发送消息
</span><span style="color:#75715e">     
</span><span style="color:#75715e">     - parameter message: 消息
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">send</span>(message: String) {
        print(<span style="color:#e6db74">&#34;Colleague </span><span style="color:#e6db74">\(</span>name<span style="color:#e6db74">)</span><span style="color:#e6db74"> send: </span><span style="color:#e6db74">\(</span>message<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
        mediator.send(message: message, colleague: <span style="color:#66d9ef">self</span>)
    }
    
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     接收消息
</span><span style="color:#75715e">     
</span><span style="color:#75715e">     - parameter message: 消息
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receive</span>(message: String) {
        assert(<span style="color:#66d9ef">false</span>, <span style="color:#e6db74">&#34;Method should be overriden&#34;</span>)
    }
}

<span style="color:#75715e">/**
</span><span style="color:#75715e"> *  中介者接口
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Mediator</span> {
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     发送消息
</span><span style="color:#75715e">     
</span><span style="color:#75715e">     - parameter message:   消息
</span><span style="color:#75715e">     - parameter colleague: 发送者
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">send</span>(message: String, colleague: Colleague)
}

<span style="color:#75715e">/// 具体中介者</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MessageMediator</span>: Mediator {
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> colleagues: [Colleague] = []
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addColleague</span>(colleague: Colleague) {
        colleagues.append(colleague)
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">send</span>(message: String, colleague: Colleague) {
        <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> colleagues {
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">!==</span> colleague { <span style="color:#75715e">//for simplicity we compare object references</span>
                c.receive(message: message)
            }
        }
    }
}

<span style="color:#75715e">/// 具体对象</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConcreteColleague</span>: Colleague {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receive</span>(message: String) {
        print(<span style="color:#e6db74">&#34;Colleague </span><span style="color:#e6db74">\(</span>name<span style="color:#e6db74">)</span><span style="color:#e6db74"> received: </span><span style="color:#e6db74">\(</span>message<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
    }
}

<span style="color:#66d9ef">let</span> messagesMediator = MessageMediator()
<span style="color:#66d9ef">let</span> c1 = ConcreteColleague(name: <span style="color:#e6db74">&#34;A&#34;</span>, mediator: messagesMediator)
<span style="color:#66d9ef">let</span> c2 = ConcreteColleague(name: <span style="color:#e6db74">&#34;B&#34;</span>, mediator: messagesMediator)
<span style="color:#66d9ef">let</span> c3 = ConcreteColleague(name: <span style="color:#e6db74">&#34;C&#34;</span>, mediator: messagesMediator)
messagesMediator.addColleague(colleague: c1)
messagesMediator.addColleague(colleague: c2)
messagesMediator.addColleague(colleague: c3)

c3.send(message: <span style="color:#e6db74">&#34;Hello&#34;</span>)
</code></pre></div><p>我们在工程中模块化解耦的方式就是使用了中介者模式。和观察者模式很像，区别在于观察者是不关心接受方的广播，中介者是介入两个（或多个）对象之间的定点消息传递。</p>
<p>优点：</p>
<ul>
<li>模块化解耦</li>
<li>减少了子类的产生</li>
<li>简化了对象间的交互</li>
</ul>
<p>缺点：</p>
<ul>
<li>中介者本省容易变得臃肿</li>
</ul>
<h3 id="观察者模式">观察者模式</h3>
<p>描述：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Observer</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiveChanges</span>()
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hashValue</span>() -&gt; Int
}

<span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Observer</span> {
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hashValue</span>() -&gt; Int {
        <span style="color:#66d9ef">return</span> Unmanaged&lt;AnyObject&gt;.passUnretained(<span style="color:#66d9ef">self</span> <span style="color:#66d9ef">as</span> AnyObject).toOpaque().hashValue
    }
}

<span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Observable</span> {
    <span style="color:#66d9ef">var</span> observers: [Observer] { <span style="color:#66d9ef">get</span> }
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(observer: Observer)
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">remove</span>(observer: Observer)
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">notify</span>()
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConcreteObserver</span>: Observer {
    <span style="color:#66d9ef">let</span> name: String
    
    <span style="color:#66d9ef">init</span>(name: String) {
        <span style="color:#66d9ef">self</span>.name = name
    }
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiveChanges</span>() {
        print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>name<span style="color:#e6db74">)</span><span style="color:#e6db74"> receive&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConcreteObservable</span>: Observable {
    
    <span style="color:#66d9ef">var</span> observers: [Observer] = []
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(observer: Observer) {
        observers.append(observer)
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">remove</span>(observer: Observer) {
        
        <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> idx = observers.firstIndex(<span style="color:#66d9ef">where</span>: { (obs) -&gt; Bool <span style="color:#66d9ef">in</span>
            <span style="color:#66d9ef">return</span> obs.hashValue() == observer.hashValue()
        }) <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span>  }
        
        observers.remove(at: idx)
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">notify</span>() {
        
        observers.forEach{
            $0.receiveChanges()
        }
    }
}

<span style="color:#66d9ef">let</span> c1 = ConcreteObserver(name: <span style="color:#e6db74">&#34;A&#34;</span>)
<span style="color:#66d9ef">let</span> c2 = ConcreteObserver(name: <span style="color:#e6db74">&#34;B&#34;</span>)
<span style="color:#66d9ef">let</span> c3 = ConcreteObserver(name: <span style="color:#e6db74">&#34;C&#34;</span>)

<span style="color:#66d9ef">let</span> observable = ConcreteObservable()
observable.add(observer: c1)
observable.add(observer: c2)
observable.add(observer: c3)

observable.notify()

observable.remove(observer: c1)
observable.notify()
</code></pre></div><p>在Cocoa框架中提供的<a href="https://k.felixplus.top/kvo/">KVO</a>和通知中心就是观察者模式的实现。</p>
<p>优点：</p>
<ul>
<li>可以实现表示层和数据逻辑层分离</li>
<li>支持广播通信</li>
</ul>
<p>缺点：</p>
<ul>
<li>将所有观察者都通知到会花费一些时间</li>
<li>需要注意循环依赖的事件发生</li>
</ul>
<h3 id="状态模式">状态模式</h3>
<p>描述：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">State</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doStuff</span>()
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StateA</span>: State {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doStuff</span>() {
        print(<span style="color:#e6db74">&#34;do some A stuff&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StateB</span>: State {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doStuff</span>() {
        print(<span style="color:#e6db74">&#34;do some B stuff&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Context</span> {
    <span style="color:#66d9ef">var</span> state: State = StateA()
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">operation</span>() {
        state.doStuff()
    }
}

<span style="color:#66d9ef">let</span> ctx = Context()

ctx.operation()

ctx.state = StateB()

ctx.operation()
</code></pre></div><p>优点：</p>
<ul>
<li>只需改变状态就可以改变类的行为</li>
<li>允许状态转换对象与状态对象合为一体</li>
<li>多个对象可以共享状态</li>
</ul>
<p>缺点：</p>
<ul>
<li>违背开闭原则</li>
<li>使用不当会使得代码结构混乱</li>
</ul>
<h3 id="备忘录模式">备忘录模式</h3>
<p>描述：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Todo</span>: Codable{
    
    <span style="color:#66d9ef">var</span> content = <span style="color:#e6db74">&#34;&#34;</span>
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Memento</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">save</span>(todo: Todo, key: String) {
        <span style="color:#66d9ef">do</span> {
            <span style="color:#66d9ef">let</span> data = <span style="color:#66d9ef">try</span> JSONEncoder().encode(todo)
            print(data)
            UserDefaults.standard.<span style="color:#66d9ef">set</span>(data, forKey: key)
            UserDefaults.standard.synchronize()
        } <span style="color:#66d9ef">catch</span> {
            print(error)
        }
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">load</span>(key: String) -&gt; Todo? {
        
        <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> data = UserDefaults.standard.data(forKey: key) <span style="color:#66d9ef">else</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }
        
        <span style="color:#66d9ef">do</span> {
            
            <span style="color:#66d9ef">let</span> todo = <span style="color:#66d9ef">try</span> JSONDecoder().decode(Todo.<span style="color:#66d9ef">self</span>, from: data)
            <span style="color:#66d9ef">return</span> todo
        } <span style="color:#66d9ef">catch</span>  {
            print(error)
        }
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
}

<span style="color:#66d9ef">let</span> todo = Todo()
<span style="color:#66d9ef">let</span> memento = Memento()

todo.content = <span style="color:#e6db74">&#34;a simple thing&#34;</span>
memento.save(todo: todo, key: <span style="color:#e6db74">&#34;key&#34;</span>)

<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> todo1 = memento.load(key: <span style="color:#e6db74">&#34;key&#34;</span>) {
    print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>todo<span style="color:#e6db74">)</span><span style="color:#e6db74"> -- </span><span style="color:#e6db74">\(</span>todo1<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
}
</code></pre></div><p>备忘录模式可以通俗的理解为游戏的存档和读档。</p>
<p>优点：</p>
<ul>
<li>提供给了用户可以保存状态的机制</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建备忘会消耗资源</li>
</ul>
<h3 id="策略模式">策略模式</h3>
<p>描述：策略模式属于对象的行为模式，将某一组算法封装起来，让它们可以相互替换，策略模式提供了一种可插入式算法的实现方案</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Strategy</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">saveData</span>()
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MemoryStrategy</span>: Strategy {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">saveData</span>() {
        print(<span style="color:#e6db74">&#34;save data to memory&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DiskStrategy</span>: Strategy {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">saveData</span>() {
        print(<span style="color:#e6db74">&#34;save data to disk&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Downloader</span> {
    <span style="color:#66d9ef">let</span> strategy: Strategy
    <span style="color:#66d9ef">init</span>(strategy: Strategy) {
        <span style="color:#66d9ef">self</span>.strategy = strategy
    }
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">download</span>() {
        <span style="color:#66d9ef">self</span>.strategy.saveData()
    }
}

Downloader(strategy: MemoryStrategy()).download()
Downloader(strategy: DiskStrategy()).download()
</code></pre></div><p>如上，当我们调用下载方法时期望能够制定我们下载后的缓存策略</p>
<p>优点：</p>
<ul>
<li>符合开闭原则，能够灵活的增加和修改实现</li>
<li>提供了算法复用的实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要自定义策略支持</li>
<li>策略过多会在选择上花费一些功夫</li>
</ul>
<h2 id="ios常见的设计模式实现">iOS常见的设计模式实现</h2>
<h3 id="单例模式-1">单例模式</h3>
<ul>
<li>UIApplication <code>sharedApplication</code></li>
<li>NSBundle <code>mainBundle</code></li>
<li>NSFileManager <code>defaultManager</code></li>
<li>NSNotificationCenter <code>defaultCenter</code></li>
<li>NSUserDefaults <code>standardUserDefaults</code></li>
</ul>
<h3 id="代理模式-1">代理模式</h3>
<ul>
<li>UITableView</li>
<li>UITextView</li>
<li>UICollectionView</li>
<li>UIScrollView</li>
<li>UIGestureRecognizer</li>
</ul>
<h3 id="观察者模式-1">观察者模式</h3>
<ul>
<li>Notification</li>
<li>KVO</li>
</ul>
<p>参考</p>
<p><a href="https://juejin.im/post/5b827f0df265da43412875dd#heading-11">https://juejin.im/post/5b827f0df265da43412875dd#heading-11</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1412368">https://cloud.tencent.com/developer/article/1412368</a></p>
<p><a href="http://www.licheng244.com/posts/06%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">http://www.licheng244.com/posts/06%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</a></p>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">Posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/tags/objc/">Arithmetic</a>
        
            &#183; 
            <a href="http://example.org/about">Who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog. <a href="mailto:cb7d23@gmail.com">cb7d23@gmail.com</a></div>
    </div>
</body>

</html>