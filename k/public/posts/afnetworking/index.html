<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Cb7d &#39;s blog">
<title>
AFNetworking 你真的了解吗 - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="AFNetworking 你真的了解吗"/>
<meta name="twitter:description" content="AFN . ├── AFCompatibilityMacros.h ├── AFHTTPSessionManager.h ├── AFHTTPSessionManager.m ├── AFNetworkReachabilityManager.h ├── AFNetworkReachabilityManager.m ├── AFNetworking.h ├── AFSecurityPolicy.h ├── AFSecurityPolicy.m ├── AFURLRequestSerialization.h ├── AFURLRequestSerialization.m ├── AFURLResponseSerialization.h ├── AFURLResponseSerialization.m ├── AFURLSessionManager.h └── AFURLSessionManager.m Why AFN 大多项目中我们都会使用网络请求去和服务端进行交互，而对于iOS开发者而言，最广为人知的网络请求框架莫过于 AFNetworking 了，那么大家有没有想过为什么广大的开发者选择了它，它对比iOS原生的网络请求有什么区别呢，下面我会总结下自己对于 AFN 的看法和体会，也希望能对一样学习的小伙伴提供一些帮助
AFN 解析 基本使用 GET
- (void)sendRequest { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSURLSessionDataTask *task = [manager GET:@&#34;http://httpbin.org/get&#34; parameters:@{@&#34;arg1&#34;:@(100), @&#34;arg2&#34;: @{@&#34;foo&#34;:@&#34;bar&#34;}} progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; } POST"/>

<meta property="og:title" content="AFNetworking 你真的了解吗" />
<meta property="og:description" content="AFN . ├── AFCompatibilityMacros.h ├── AFHTTPSessionManager.h ├── AFHTTPSessionManager.m ├── AFNetworkReachabilityManager.h ├── AFNetworkReachabilityManager.m ├── AFNetworking.h ├── AFSecurityPolicy.h ├── AFSecurityPolicy.m ├── AFURLRequestSerialization.h ├── AFURLRequestSerialization.m ├── AFURLResponseSerialization.h ├── AFURLResponseSerialization.m ├── AFURLSessionManager.h └── AFURLSessionManager.m Why AFN 大多项目中我们都会使用网络请求去和服务端进行交互，而对于iOS开发者而言，最广为人知的网络请求框架莫过于 AFNetworking 了，那么大家有没有想过为什么广大的开发者选择了它，它对比iOS原生的网络请求有什么区别呢，下面我会总结下自己对于 AFN 的看法和体会，也希望能对一样学习的小伙伴提供一些帮助
AFN 解析 基本使用 GET
- (void)sendRequest { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSURLSessionDataTask *task = [manager GET:@&#34;http://httpbin.org/get&#34; parameters:@{@&#34;arg1&#34;:@(100), @&#34;arg2&#34;: @{@&#34;foo&#34;:@&#34;bar&#34;}} progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; } POST" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/afnetworking/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2018-03-13T10:46:42+08:00" />
<meta property="article:modified_time" content="2018-03-13T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d &#39;s blog" />


    

    
    
    
    <title>
        
        AFNetworking 你真的了解吗
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">AFNetworking 你真的了解吗</div>

        
<div class="section" id="content">
    Tue Mar 13, 2018 &#183; 1815 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
        
        
    </div>
    <hr/>
    <h1 id="afn">AFN</h1>
<pre><code>.
├── AFCompatibilityMacros.h
├── AFHTTPSessionManager.h
├── AFHTTPSessionManager.m
├── AFNetworkReachabilityManager.h
├── AFNetworkReachabilityManager.m
├── AFNetworking.h
├── AFSecurityPolicy.h
├── AFSecurityPolicy.m
├── AFURLRequestSerialization.h
├── AFURLRequestSerialization.m
├── AFURLResponseSerialization.h
├── AFURLResponseSerialization.m
├── AFURLSessionManager.h
└── AFURLSessionManager.m

</code></pre><h2 id="why-afn">Why AFN</h2>
<p>大多项目中我们都会使用网络请求去和服务端进行交互，而对于iOS开发者而言，最广为人知的网络请求框架莫过于 <strong>AFNetworking</strong> 了，那么大家有没有想过为什么广大的开发者选择了它，它对比iOS原生的网络请求有什么区别呢，下面我会总结下自己对于 AFN 的看法和体会，也希望能对一样学习的小伙伴提供一些帮助</p>
<h2 id="afn-解析">AFN 解析</h2>
<h3 id="基本使用">基本使用</h3>
<p><strong>GET</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sendRequest</span> {
    
    AFHTTPSessionManager <span style="color:#f92672">*</span>manager <span style="color:#f92672">=</span> [AFHTTPSessionManager manager];
    NSURLSessionDataTask <span style="color:#f92672">*</span>task <span style="color:#f92672">=</span> [manager GET:<span style="color:#e6db74">@&#34;http://httpbin.org/get&#34;</span> parameters:<span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;arg1&#34;</span><span style="color:#f92672">:</span><span style="color:#ae81ff">@(</span><span style="color:#ae81ff">100</span><span style="color:#ae81ff">)</span>, <span style="color:#e6db74">@&#34;arg2&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;foo&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">@&#34;bar&#34;</span><span style="color:#ae81ff">}}</span> progress:nil success:<span style="color:#f92672">^</span>(NSURLSessionDataTask <span style="color:#f92672">*</span> _Nonnull task, <span style="color:#66d9ef">id</span>  _Nullable responseObject) {
        
    } failure:<span style="color:#f92672">^</span>(NSURLSessionDataTask <span style="color:#f92672">*</span> _Nullable task, NSError <span style="color:#f92672">*</span> _Nonnull error) {
        
    }];
}

</code></pre></div><p><strong>POST</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sendRequest</span> {
    AFHTTPSessionManager <span style="color:#f92672">*</span>manager <span style="color:#f92672">=</span> [AFHTTPSessionManager manager];
    NSURLSessionDataTask <span style="color:#f92672">*</span>task <span style="color:#f92672">=</span> [manager POST:<span style="color:#e6db74">@&#34;http://httpbin.org/post&#34;</span> parameters:<span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;arg1&#34;</span><span style="color:#f92672">:</span><span style="color:#ae81ff">@(</span><span style="color:#ae81ff">100</span><span style="color:#ae81ff">)</span>, <span style="color:#e6db74">@&#34;arg2&#34;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;foo&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">@&#34;bar&#34;</span><span style="color:#ae81ff">}}</span> progress:nil success:<span style="color:#f92672">^</span>(NSURLSessionDataTask <span style="color:#f92672">*</span> _Nonnull task, <span style="color:#66d9ef">id</span>  _Nullable responseObject) {

    } failure:<span style="color:#f92672">^</span>(NSURLSessionDataTask <span style="color:#f92672">*</span> _Nullable task, NSError <span style="color:#f92672">*</span> _Nonnull error) {

    }];
}

</code></pre></div><p>这是最简单的使用方法，下面我们一层一层分析<strong>AFN</strong>是怎样处理一个请求的</p>
<h3 id="接口部分-afhttpsessionmanager--afurlsessionmanager">接口部分 AFHTTPSessionManager &amp; AFURLSessionManager</h3>
<p><strong>AFHTTPSessionManager</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">+ (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">manager</span> {
    <span style="color:#66d9ef">return</span> [[[self <span style="color:#66d9ef">class</span>] alloc] initWithBaseURL:nil];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    <span style="color:#66d9ef">return</span> [self initWithBaseURL:nil];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithBaseURL:</span>(NSURL <span style="color:#f92672">*</span>)url {
    <span style="color:#66d9ef">return</span> [self initWithBaseURL:url sessionConfiguration:nil];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithSessionConfiguration:</span>(NSURLSessionConfiguration <span style="color:#f92672">*</span>)configuration {
    <span style="color:#66d9ef">return</span> [self initWithBaseURL:nil sessionConfiguration:configuration];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithBaseURL:</span>(NSURL <span style="color:#f92672">*</span>)url
           <span style="color:#a6e22e">sessionConfiguration:</span>(NSURLSessionConfiguration <span style="color:#f92672">*</span>)configuration
{
    self <span style="color:#f92672">=</span> [super initWithSessionConfiguration:configuration];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self) {
        <span style="color:#66d9ef">return</span> nil;
    }

    <span style="color:#75715e">// 这里为baseURL做处理，如果传入的URL没有加最后的斜杠这里会补上
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([[url path] length] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>[[url absoluteString] hasSuffix:<span style="color:#e6db74">@&#34;/&#34;</span>]) {
        url <span style="color:#f92672">=</span> [url URLByAppendingPathComponent:<span style="color:#e6db74">@&#34;&#34;</span>];
    }

    self.baseURL <span style="color:#f92672">=</span> url;
		
    <span style="color:#75715e">// 这里初始化了请求和响应的序列化对象，默认使用json作为响应的序列化方式
</span><span style="color:#75715e"></span>    self.requestSerializer <span style="color:#f92672">=</span> [AFHTTPRequestSerializer serializer];
    self.responseSerializer <span style="color:#f92672">=</span> [AFJSONResponseSerializer serializer];

    <span style="color:#66d9ef">return</span> self;
}
</code></pre></div><p>由于<strong>AFHTTPSessionManager</strong>是继承于<strong>AFURLSessionManager</strong>，我们接下来看下<strong>AFURLSessionManager</strong>的初始化方法</p>
<p><strong>AFURLSessionManager</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithSessionConfiguration:</span>(NSURLSessionConfiguration <span style="color:#f92672">*</span>)configuration {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self) {
        <span style="color:#66d9ef">return</span> nil;
    }
		<span style="color:#75715e">// 如果没有传入 NSURLSessionConfiguration 则初始化为 defaultSessionConfiguration
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>configuration) {
        configuration <span style="color:#f92672">=</span> [NSURLSessionConfiguration defaultSessionConfiguration];
    }

    self.sessionConfiguration <span style="color:#f92672">=</span> configuration;
		
  	<span style="color:#75715e">// 初始化网络请求回调的队列
</span><span style="color:#75715e"></span>    self.operationQueue <span style="color:#f92672">=</span> [[NSOperationQueue alloc] init];
    self.operationQueue.maxConcurrentOperationCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
		
  	<span style="color:#75715e">// 初始化 NSURLSession
</span><span style="color:#75715e"></span>    self.session <span style="color:#f92672">=</span> [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    self.responseSerializer <span style="color:#f92672">=</span> [AFJSONResponseSerializer serializer];
		
  	<span style="color:#75715e">// 默认安全策略 AFSSLPinningModeNone
</span><span style="color:#75715e"></span>    self.securityPolicy <span style="color:#f92672">=</span> [AFSecurityPolicy defaultPolicy];

<span style="color:#75715e">#if !TARGET_OS_WATCH
</span><span style="color:#75715e"></span>    self.reachabilityManager <span style="color:#f92672">=</span> [AFNetworkReachabilityManager sharedManager];
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>		
  	<span style="color:#75715e">// 初始化任务代理的Map
</span><span style="color:#75715e"></span>    self.mutableTaskDelegatesKeyedByTaskIdentifier <span style="color:#f92672">=</span> [[NSMutableDictionary alloc] init];
		
  	<span style="color:#75715e">// 初始化锁
</span><span style="color:#75715e"></span>    self.lock <span style="color:#f92672">=</span> [[NSLock alloc] init];
    self.lock.name <span style="color:#f92672">=</span> AFURLSessionManagerLockName;
		
  	<span style="color:#75715e">// 后台进入时重新写入代理
</span><span style="color:#75715e"></span>    [self.session getTasksWithCompletionHandler:<span style="color:#f92672">^</span>(NSArray <span style="color:#f92672">*</span>dataTasks, NSArray <span style="color:#f92672">*</span>uploadTasks, NSArray <span style="color:#f92672">*</span>downloadTasks) {
        <span style="color:#66d9ef">for</span> (NSURLSessionDataTask <span style="color:#f92672">*</span>task <span style="color:#66d9ef">in</span> dataTasks) {
            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
        }

        <span style="color:#66d9ef">for</span> (NSURLSessionUploadTask <span style="color:#f92672">*</span>uploadTask <span style="color:#66d9ef">in</span> uploadTasks) {
            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
        }

        <span style="color:#66d9ef">for</span> (NSURLSessionDownloadTask <span style="color:#f92672">*</span>downloadTask <span style="color:#66d9ef">in</span> downloadTasks) {
            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
        }
    }];

    <span style="color:#66d9ef">return</span> self;
}
</code></pre></div><p>说完了初始化我们来看具体的一个请求发送</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (NSURLSessionDataTask <span style="color:#f92672">*</span>)<span style="color:#a6e22e">GET:</span>(NSString <span style="color:#f92672">*</span>)URLString
                   <span style="color:#a6e22e">parameters:</span>(<span style="color:#66d9ef">id</span>)parameters
                      <span style="color:#a6e22e">success:</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSURLSessionDataTask <span style="color:#f92672">*</span>task, <span style="color:#66d9ef">id</span> responseObject))success
                      <span style="color:#a6e22e">failure:</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSURLSessionDataTask <span style="color:#f92672">*</span>task, NSError <span style="color:#f92672">*</span>error))failure
{

    <span style="color:#66d9ef">return</span> [self GET:URLString parameters:parameters progress:nil success:success failure:failure];
}
</code></pre></div><p>最终会进入这个方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (NSURLSessionDataTask <span style="color:#f92672">*</span>)<span style="color:#a6e22e">dataTaskWithHTTPMethod:</span>(NSString <span style="color:#f92672">*</span>)method
                                       <span style="color:#a6e22e">URLString:</span>(NSString <span style="color:#f92672">*</span>)URLString
                                      <span style="color:#a6e22e">parameters:</span>(<span style="color:#66d9ef">id</span>)parameters
                                  <span style="color:#a6e22e">uploadProgress:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSProgress <span style="color:#f92672">*</span>uploadProgress)) uploadProgress
                                <span style="color:#a6e22e">downloadProgress:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSProgress <span style="color:#f92672">*</span>downloadProgress)) downloadProgress
                                         <span style="color:#a6e22e">success:</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSURLSessionDataTask <span style="color:#f92672">*</span>, <span style="color:#66d9ef">id</span>))success
                                         <span style="color:#a6e22e">failure:</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSURLSessionDataTask <span style="color:#f92672">*</span>, NSError <span style="color:#f92672">*</span>))failure
{
    NSError <span style="color:#f92672">*</span>serializationError <span style="color:#f92672">=</span> nil;
		
		<span style="color:#75715e">// 由 requestSerializer 负责具体请求的解析 ,requestSerializer 部分下面会说
</span><span style="color:#75715e"></span>    NSMutableURLRequest <span style="color:#f92672">*</span>request <span style="color:#f92672">=</span> [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:<span style="color:#f92672">&amp;</span>serializationError];
                                          
		<span style="color:#75715e">// 如果请求解析失败返回nil，直接通过block返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (serializationError) {
        <span style="color:#66d9ef">if</span> (failure) {
            dispatch_async(self.completionQueue <span style="color:#f92672">?:</span> dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                failure(nil, serializationError);
            });
        }

        <span style="color:#66d9ef">return</span> nil;
    }

    <span style="color:#66d9ef">__block</span> NSURLSessionDataTask <span style="color:#f92672">*</span>dataTask <span style="color:#f92672">=</span> nil;
    dataTask <span style="color:#f92672">=</span> [self dataTaskWithRequest:request
                          uploadProgress:uploadProgress
                        downloadProgress:downloadProgress
                       completionHandler:<span style="color:#f92672">^</span>(NSURLResponse <span style="color:#f92672">*</span> __unused response, <span style="color:#66d9ef">id</span> responseObject, NSError <span style="color:#f92672">*</span>error) {
        <span style="color:#66d9ef">if</span> (error) {
            <span style="color:#66d9ef">if</span> (failure) {
                failure(dataTask, error);
            }
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (success) {
                success(dataTask, responseObject);
            }
        }
    }];

    <span style="color:#66d9ef">return</span> dataTask;
}
</code></pre></div><p>再之后会进入这个方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (NSURLSessionDataTask <span style="color:#f92672">*</span>)<span style="color:#a6e22e">dataTaskWithRequest:</span>(NSURLRequest <span style="color:#f92672">*</span>)request
                               <span style="color:#a6e22e">uploadProgress:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSProgress <span style="color:#f92672">*</span>uploadProgress)) uploadProgressBlock
                             <span style="color:#a6e22e">downloadProgress:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSProgress <span style="color:#f92672">*</span>downloadProgress)) downloadProgressBlock
                            <span style="color:#a6e22e">completionHandler:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSURLResponse <span style="color:#f92672">*</span>response, <span style="color:#66d9ef">id</span> _Nullable responseObject,  NSError <span style="color:#f92672">*</span> _Nullable error))completionHandler {

    <span style="color:#66d9ef">__block</span> NSURLSessionDataTask <span style="color:#f92672">*</span>dataTask <span style="color:#f92672">=</span> nil;
    url_session_manager_create_task_safely(<span style="color:#f92672">^</span>{
        dataTask <span style="color:#f92672">=</span> [self.session dataTaskWithRequest:request];
    });

    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];

    <span style="color:#66d9ef">return</span> dataTask;
}
</code></pre></div><p>这里 <strong>url_session_manager_create_task_safely</strong> 解决了iOS8.0之前并行创建出来的 <strong>task</strong> 的 <strong>taskIdentifier</strong> 不唯一的BUG，实现起来就是使用GCD创建了一个串行队列进行task的操作，如下所示</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#66d9ef">static</span> dispatch_queue_t <span style="color:#a6e22e">url_session_manager_creation_queue</span>() {
    <span style="color:#66d9ef">static</span> dispatch_queue_t af_url_session_manager_creation_queue;
    <span style="color:#66d9ef">static</span> dispatch_once_t onceToken;
    dispatch_once(<span style="color:#f92672">&amp;</span>onceToken, <span style="color:#f92672">^</span>{
        af_url_session_manager_creation_queue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;com.alamofire.networking.session.manager.creation&#34;</span>, DISPATCH_QUEUE_SERIAL);
    });

    <span style="color:#66d9ef">return</span> af_url_session_manager_creation_queue;
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">url_session_manager_create_task_safely</span>(dispatch_block_t block) {
    <span style="color:#66d9ef">if</span> (NSFoundationVersionNumber <span style="color:#f92672">&lt;</span> NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {
        <span style="color:#75715e">// Fix of bug
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093
</span><span style="color:#75715e"></span>        dispatch_sync(url_session_manager_creation_queue(), block);
    } <span style="color:#66d9ef">else</span> {
        block();
    }
}
</code></pre></div><p>接下来继续查看上面的为task添加代理的方法 <strong>addDelegateForDataTask</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addDelegateForDataTask:</span>(NSURLSessionDataTask <span style="color:#f92672">*</span>)dataTask
                <span style="color:#a6e22e">uploadProgress:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSProgress <span style="color:#f92672">*</span>uploadProgress)) uploadProgressBlock
              <span style="color:#a6e22e">downloadProgress:</span>(nullable <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSProgress <span style="color:#f92672">*</span>downloadProgress)) downloadProgressBlock
             <span style="color:#a6e22e">completionHandler:</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(NSURLResponse <span style="color:#f92672">*</span>response, <span style="color:#66d9ef">id</span> responseObject, NSError <span style="color:#f92672">*</span>error))completionHandler
{
    <span style="color:#75715e">// 初始化代理对象，整个任务的进度和回调由代理负责管理
</span><span style="color:#75715e"></span>    AFURLSessionManagerTaskDelegate <span style="color:#f92672">*</span>delegate <span style="color:#f92672">=</span> [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];
    delegate.manager <span style="color:#f92672">=</span> self;
    delegate.completionHandler <span style="color:#f92672">=</span> completionHandler;

    dataTask.taskDescription <span style="color:#f92672">=</span> self.taskDescriptionForSessionTasks;
    <span style="color:#75715e">// 将代理与对象关联，存进Map
</span><span style="color:#75715e"></span>    [self setDelegate:delegate forTask:dataTask];

    delegate.uploadProgressBlock <span style="color:#f92672">=</span> uploadProgressBlock;
    delegate.downloadProgressBlock <span style="color:#f92672">=</span> downloadProgressBlock;
}
</code></pre></div><p>由于对字典的操作不是线程安全的，所以使用 <strong>NSLock</strong> 加锁</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setDelegate:</span>(AFURLSessionManagerTaskDelegate <span style="color:#f92672">*</span>)delegate
            <span style="color:#a6e22e">forTask:</span>(NSURLSessionTask <span style="color:#f92672">*</span>)task
{
    NSParameterAssert(task);
    NSParameterAssert(delegate);

    [self.lock lock];
    self.mutableTaskDelegatesKeyedByTaskIdentifier[<span style="color:#ae81ff">@(</span>task.taskIdentifier<span style="color:#ae81ff">)</span>] <span style="color:#f92672">=</span> delegate;
    [self addNotificationObserverForTask:task];
    [self.lock unlock];
}
</code></pre></div><p>添加监听</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addNotificationObserverForTask:</span>(NSURLSessionTask <span style="color:#f92672">*</span>)task {
    [[NSNotificationCenter defaultCenter] addObserver:self selector:<span style="color:#66d9ef">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:<span style="color:#66d9ef">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];
}
</code></pre></div><p>在监听到状态变化时向外部发出通知，方便外部处理</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">taskDidResume:</span>(NSNotification <span style="color:#f92672">*</span>)notification {
    NSURLSessionTask <span style="color:#f92672">*</span>task <span style="color:#f92672">=</span> notification.object;
    <span style="color:#66d9ef">if</span> ([task respondsToSelector:<span style="color:#66d9ef">@selector</span>(taskDescription)]) {
        <span style="color:#66d9ef">if</span> ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) {
            dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];
            });
        }
    }
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">taskDidSuspend:</span>(NSNotification <span style="color:#f92672">*</span>)notification {
    NSURLSessionTask <span style="color:#f92672">*</span>task <span style="color:#f92672">=</span> notification.object;
    <span style="color:#66d9ef">if</span> ([task respondsToSelector:<span style="color:#66d9ef">@selector</span>(taskDescription)]) {
        <span style="color:#66d9ef">if</span> ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) {
            dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task];
            });
        }
    }
}
</code></pre></div><p>下面主要看 <strong>AFURLSessionManagerTaskDelegate</strong> 实现的这个方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#75715e">#pragma mark - NSURLSessionTaskDelegate
</span><span style="color:#75715e"></span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">URLSession:</span>(__unused NSURLSession <span style="color:#f92672">*</span>)session
              <span style="color:#a6e22e">task:</span>(NSURLSessionTask <span style="color:#f92672">*</span>)task
<span style="color:#a6e22e">didCompleteWithError:</span>(NSError <span style="color:#f92672">*</span>)error
{
  	<span style="color:#75715e">// 取出 AFURLSessionManager
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__strong</span> AFURLSessionManager <span style="color:#f92672">*</span>manager <span style="color:#f92672">=</span> self.manager;

    <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">id</span> responseObject <span style="color:#f92672">=</span> nil;

    <span style="color:#66d9ef">__block</span> NSMutableDictionary <span style="color:#f92672">*</span>userInfo <span style="color:#f92672">=</span> [NSMutableDictionary dictionary];
    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] <span style="color:#f92672">=</span> manager.responseSerializer;

    <span style="color:#75715e">// 当请求完成后释放内存
</span><span style="color:#75715e"></span>    NSData <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> nil;
    <span style="color:#66d9ef">if</span> (self.mutableData) {
        data <span style="color:#f92672">=</span> [self.mutableData <span style="color:#66d9ef">copy</span>];
        <span style="color:#75715e">//We no longer need the reference, so nil it out to gain back some memory.
</span><span style="color:#75715e"></span>        self.mutableData <span style="color:#f92672">=</span> nil;
    }

    <span style="color:#66d9ef">if</span> (self.downloadFileURL) {
        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] <span style="color:#f92672">=</span> self.downloadFileURL;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (data) {
        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] <span style="color:#f92672">=</span> data;
    }

    <span style="color:#66d9ef">if</span> (error) {
        userInfo[AFNetworkingTaskDidCompleteErrorKey] <span style="color:#f92672">=</span> error;
				
      	<span style="color:#75715e">// 异步添加到GCD任务组，如果没有指定会默认生成一个，回调队列如果没有指定会默认为主队列
</span><span style="color:#75715e"></span>        dispatch_group_async(manager.completionGroup <span style="color:#f92672">?:</span> url_session_manager_completion_group(), manager.completionQueue <span style="color:#f92672">?:</span> dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
            <span style="color:#66d9ef">if</span> (self.completionHandler) {
                self.completionHandler(task.response, responseObject, error);
            }
						
          	<span style="color:#75715e">// 在主队列中发送AFNetworkingTaskDidCompleteNotification通知
</span><span style="color:#75715e"></span>            dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
            });
        });
    } <span style="color:#66d9ef">else</span> {
        dispatch_async(url_session_manager_processing_queue(), <span style="color:#f92672">^</span>{
            NSError <span style="color:#f92672">*</span>serializationError <span style="color:#f92672">=</span> nil;
            responseObject <span style="color:#f92672">=</span> [manager.responseSerializer responseObjectForResponse:task.response data:data error:<span style="color:#f92672">&amp;</span>serializationError];

            <span style="color:#66d9ef">if</span> (self.downloadFileURL) {
                responseObject <span style="color:#f92672">=</span> self.downloadFileURL;
            }

            <span style="color:#66d9ef">if</span> (responseObject) {
                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] <span style="color:#f92672">=</span> responseObject;
            }

            <span style="color:#66d9ef">if</span> (serializationError) {
                userInfo[AFNetworkingTaskDidCompleteErrorKey] <span style="color:#f92672">=</span> serializationError;
            }

            dispatch_group_async(manager.completionGroup <span style="color:#f92672">?:</span> url_session_manager_completion_group(), manager.completionQueue <span style="color:#f92672">?:</span> dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                <span style="color:#66d9ef">if</span> (self.completionHandler) {
                    self.completionHandler(task.response, responseObject, serializationError);
                }

                dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
                });
            });
        });
    }
}
</code></pre></div><p><strong>manager</strong> 和 <strong>taskDelegate</strong> 部分先看到这里</p>
<h3 id="序列化部分-afurlrequestserialization--afurlresponseserialization">序列化部分 AFURLRequestSerialization &amp; AFURLResponseSerialization</h3>
<h4 id="先从-afurlrequestserialization-开始看起">先从 <strong>AFURLRequestSerialization</strong> 开始看起</h4>
<p>首先，AFURLRequestSerialization 只是协议，具体实现由遵守协议的类来实现，我们主要看 <strong>AFHTTPRequestSerializer</strong> 这个类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self) {
        <span style="color:#66d9ef">return</span> nil;
    }
		
  	<span style="color:#75715e">// 设置默认字符串编码
</span><span style="color:#75715e"></span>    self.stringEncoding <span style="color:#f92672">=</span> NSUTF8StringEncoding;
	
  	<span style="color:#75715e">// 初始化请求头的Map
</span><span style="color:#75715e"></span>    self.mutableHTTPRequestHeaders <span style="color:#f92672">=</span> [NSMutableDictionary dictionary];
  	<span style="color:#75715e">// 为头部Map的变动创建一个并行队列
</span><span style="color:#75715e"></span>    self.requestHeaderModificationQueue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;requestHeaderModificationQueue&#34;</span>, DISPATCH_QUEUE_CONCURRENT);

    <span style="color:#75715e">// 设置头部的 acceptLanguages
</span><span style="color:#75715e"></span>    NSMutableArray <span style="color:#f92672">*</span>acceptLanguagesComponents <span style="color:#f92672">=</span> [NSMutableArray array];
    [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:<span style="color:#f92672">^</span>(<span style="color:#66d9ef">id</span> obj, NSUInteger idx, <span style="color:#66d9ef">BOOL</span> <span style="color:#f92672">*</span>stop) {
        <span style="color:#66d9ef">float</span> q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span> <span style="color:#f92672">-</span> (idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1f</span>);
        [acceptLanguagesComponents addObject:[NSString stringWithFormat:<span style="color:#e6db74">@&#34;%@;q=%0.1g&#34;</span>, obj, q]];
        <span style="color:#f92672">*</span>stop <span style="color:#f92672">=</span> q <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0.5f</span>;
    }];
    [self setValue:[acceptLanguagesComponents componentsJoinedByString:<span style="color:#e6db74">@&#34;, &#34;</span>] forHTTPHeaderField:<span style="color:#e6db74">@&#34;Accept-Language&#34;</span>];
		
  	<span style="color:#75715e">// UA 标识符
</span><span style="color:#75715e"></span>    NSString <span style="color:#f92672">*</span>userAgent <span style="color:#f92672">=</span> nil;
<span style="color:#75715e">#if TARGET_OS_IOS
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43
</span><span style="color:#75715e"></span>    userAgent <span style="color:#f92672">=</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;%@/%@ (%@; iOS %@; Scale/%0.2f)&#34;</span>, [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleExecutableKey] <span style="color:#f92672">?:</span> [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][<span style="color:#e6db74">@&#34;CFBundleShortVersionString&#34;</span>] <span style="color:#f92672">?:</span> [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];
<span style="color:#75715e">#elif TARGET_OS_WATCH
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43
</span><span style="color:#75715e"></span>    userAgent <span style="color:#f92672">=</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;%@/%@ (%@; watchOS %@; Scale/%0.2f)&#34;</span>, [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleExecutableKey] <span style="color:#f92672">?:</span> [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][<span style="color:#e6db74">@&#34;CFBundleShortVersionString&#34;</span>] <span style="color:#f92672">?:</span> [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]];
<span style="color:#75715e">#elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
</span><span style="color:#75715e"></span>    userAgent <span style="color:#f92672">=</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;%@/%@ (Mac OS X %@)&#34;</span>, [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleExecutableKey] <span style="color:#f92672">?:</span> [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][<span style="color:#e6db74">@&#34;CFBundleShortVersionString&#34;</span>] <span style="color:#f92672">?:</span> [[NSBundle mainBundle] infoDictionary][(<span style="color:#66d9ef">__bridge</span> NSString <span style="color:#f92672">*</span>)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (userAgent) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) {
            NSMutableString <span style="color:#f92672">*</span>mutableUserAgent <span style="color:#f92672">=</span> [userAgent mutableCopy];
            <span style="color:#66d9ef">if</span> (CFStringTransform((<span style="color:#66d9ef">__bridge</span> CFMutableStringRef)(mutableUserAgent), NULL, (<span style="color:#66d9ef">__bridge</span> CFStringRef)<span style="color:#e6db74">@&#34;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&#34;</span>, false)) {
                userAgent <span style="color:#f92672">=</span> mutableUserAgent;
            }
        }
        [self setValue:userAgent forHTTPHeaderField:<span style="color:#e6db74">@&#34;User-Agent&#34;</span>];
    }

    <span style="color:#75715e">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">// 只有这几种请求Type会将参数编码进URL中
</span><span style="color:#75715e"></span>    self.HTTPMethodsEncodingParametersInURI <span style="color:#f92672">=</span> [NSSet setWithObjects:<span style="color:#e6db74">@&#34;GET&#34;</span>, <span style="color:#e6db74">@&#34;HEAD&#34;</span>, <span style="color:#e6db74">@&#34;DELETE&#34;</span>, nil];

  	<span style="color:#960050;background-color:#1e0010">监听</span> AFHTTPRequestSerializerObservedKeyPaths <span style="color:#960050;background-color:#1e0010">包含的</span>key
    self.mutableObservedChangedKeyPaths <span style="color:#f92672">=</span> [NSMutableSet set];
    <span style="color:#66d9ef">for</span> (NSString <span style="color:#f92672">*</span>keyPath <span style="color:#66d9ef">in</span> AFHTTPRequestSerializerObservedKeyPaths()) {
        <span style="color:#66d9ef">if</span> ([self respondsToSelector:NSSelectorFromString(keyPath)]) {
            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];
        }
    }

    <span style="color:#66d9ef">return</span> self;
}
</code></pre></div><p>这里观察的有这些，观察这些也是为了能够在相关的属性被设置的时候可以及时更新</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#75715e">// 允许蜂窝网络访问
</span><span style="color:#75715e">// 缓存策略
</span><span style="color:#75715e">// 是否响应setCookie
</span><span style="color:#75715e">// http 复用 tcp 连接
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> NSArray <span style="color:#f92672">*</span> <span style="color:#a6e22e">AFHTTPRequestSerializerObservedKeyPaths</span>() {
    <span style="color:#66d9ef">static</span> NSArray <span style="color:#f92672">*</span>_AFHTTPRequestSerializerObservedKeyPaths <span style="color:#f92672">=</span> nil;
    <span style="color:#66d9ef">static</span> dispatch_once_t onceToken;
    dispatch_once(<span style="color:#f92672">&amp;</span>onceToken, <span style="color:#f92672">^</span>{
        _AFHTTPRequestSerializerObservedKeyPaths <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[</span>NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(allowsCellularAccess)), NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(cachePolicy)), NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(HTTPShouldHandleCookies)), NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(HTTPShouldUsePipelining)), NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(networkServiceType)), NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(timeoutInterval))<span style="color:#ae81ff">]</span>;
    });

    <span style="color:#66d9ef">return</span> _AFHTTPRequestSerializerObservedKeyPaths;
}
</code></pre></div><p>在获取 <strong>header</strong> 的时候使用串行队列同步进行获取，保障数据一致性</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (NSDictionary <span style="color:#f92672">*</span>)<span style="color:#a6e22e">HTTPRequestHeaders</span> {
    NSDictionary <span style="color:#66d9ef">__block</span> <span style="color:#f92672">*</span>value;
    dispatch_sync(self.requestHeaderModificationQueue, <span style="color:#f92672">^</span>{
        value <span style="color:#f92672">=</span> [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];
    });
    <span style="color:#66d9ef">return</span> value;
}
</code></pre></div><p>在设置 <strong>header</strong> 的时候使用GCD的栅栏函数保证顺序设置</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setValue:</span>(NSString <span style="color:#f92672">*</span>)value
<span style="color:#a6e22e">forHTTPHeaderField:</span>(NSString <span style="color:#f92672">*</span>)field
{
    dispatch_barrier_async(self.requestHeaderModificationQueue, <span style="color:#f92672">^</span>{
        [self.mutableHTTPRequestHeaders setValue:value forKey:field];
    });
}
</code></pre></div><p>在请求序列化的时候还贴心的为我们实现了 <strong>HTTP BASIC</strong> 认证</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setAuthorizationHeaderFieldWithUsername:</span>(NSString <span style="color:#f92672">*</span>)username
                                       <span style="color:#a6e22e">password:</span>(NSString <span style="color:#f92672">*</span>)password
{
    NSData <span style="color:#f92672">*</span>basicAuthCredentials <span style="color:#f92672">=</span> [[NSString stringWithFormat:<span style="color:#e6db74">@&#34;%@:%@&#34;</span>, username, password] dataUsingEncoding:NSUTF8StringEncoding];
    NSString <span style="color:#f92672">*</span>base64AuthCredentials <span style="color:#f92672">=</span> [basicAuthCredentials base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)<span style="color:#ae81ff">0</span>];
    [self setValue:[NSString stringWithFormat:<span style="color:#e6db74">@&#34;Basic %@&#34;</span>, base64AuthCredentials] forHTTPHeaderField:<span style="color:#e6db74">@&#34;Authorization&#34;</span>];
}
</code></pre></div><p>下面具体看初始化Request的阶段</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (NSMutableURLRequest <span style="color:#f92672">*</span>)<span style="color:#a6e22e">requestWithMethod:</span>(NSString <span style="color:#f92672">*</span>)method
                                 <span style="color:#a6e22e">URLString:</span>(NSString <span style="color:#f92672">*</span>)URLString
                                <span style="color:#a6e22e">parameters:</span>(<span style="color:#66d9ef">id</span>)parameters
                                     <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">*</span><span style="color:#66d9ef">__autoreleasing</span> <span style="color:#f92672">*</span>)error
{
    NSParameterAssert(method);
    NSParameterAssert(URLString);

		<span style="color:#75715e">// 生成url
</span><span style="color:#75715e"></span>    NSURL <span style="color:#f92672">*</span>url <span style="color:#f92672">=</span> [NSURL URLWithString:URLString];

    NSParameterAssert(url);
		
		<span style="color:#75715e">// 生成request并设置http方法
</span><span style="color:#75715e"></span>    NSMutableURLRequest <span style="color:#f92672">*</span>mutableRequest <span style="color:#f92672">=</span> [[NSMutableURLRequest alloc] initWithURL:url];
    mutableRequest.HTTPMethod <span style="color:#f92672">=</span> method;
		
		<span style="color:#75715e">// 取出观察的对象，使用KVC对request进行设置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (NSString <span style="color:#f92672">*</span>keyPath <span style="color:#66d9ef">in</span> AFHTTPRequestSerializerObservedKeyPaths()) {
        <span style="color:#66d9ef">if</span> ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
        }
    }

    mutableRequest <span style="color:#f92672">=</span> [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];

	<span style="color:#66d9ef">return</span> mutableRequest;
}
</code></pre></div><p>下面还有进一步的解析</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (NSURLRequest <span style="color:#f92672">*</span>)<span style="color:#a6e22e">requestBySerializingRequest:</span>(NSURLRequest <span style="color:#f92672">*</span>)request
                               <span style="color:#a6e22e">withParameters:</span>(<span style="color:#66d9ef">id</span>)parameters
                                        <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">*</span><span style="color:#66d9ef">__autoreleasing</span> <span style="color:#f92672">*</span>)error
{
    NSParameterAssert(request);

    NSMutableURLRequest <span style="color:#f92672">*</span>mutableRequest <span style="color:#f92672">=</span> [request mutableCopy];

		<span style="color:#75715e">// 设置Header
</span><span style="color:#75715e"></span>    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:<span style="color:#f92672">^</span>(<span style="color:#66d9ef">id</span> field, <span style="color:#66d9ef">id</span> value, <span style="color:#66d9ef">BOOL</span> <span style="color:#f92672">*</span> __unused stop) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[request valueForHTTPHeaderField:field]) {
            [mutableRequest setValue:value forHTTPHeaderField:field];
        }
    }];

		<span style="color:#75715e">// 传入的参数会进行解析，如果没有传入解析handler会使用默认的
</span><span style="color:#75715e"></span>    NSString <span style="color:#f92672">*</span>query <span style="color:#f92672">=</span> nil;
    <span style="color:#66d9ef">if</span> (parameters) {
        <span style="color:#66d9ef">if</span> (self.queryStringSerialization) {
            NSError <span style="color:#f92672">*</span>serializationError;
            query <span style="color:#f92672">=</span> self.queryStringSerialization(request, parameters, <span style="color:#f92672">&amp;</span>serializationError);

            <span style="color:#66d9ef">if</span> (serializationError) {
                <span style="color:#66d9ef">if</span> (error) {
                    <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> serializationError;
                }

                <span style="color:#66d9ef">return</span> nil;
            }
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">switch</span> (self.queryStringSerializationStyle) {
                <span style="color:#66d9ef">case</span> AFHTTPRequestQueryStringDefaultStyle:
                    query <span style="color:#f92672">=</span> AFQueryStringFromParameters(parameters);
                    <span style="color:#66d9ef">break</span>;
            }
        }
    }

		<span style="color:#75715e">// 如果请求的类型是（GET，HEAD，DELETE）就将参数编码进URL中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {
        <span style="color:#66d9ef">if</span> (query <span style="color:#f92672">&amp;&amp;</span> query.length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
            mutableRequest.URL <span style="color:#f92672">=</span> [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query <span style="color:#f92672">?</span> <span style="color:#e6db74">@&#34;&amp;%@&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">@&#34;?%@&#34;</span>, query]];
        }
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 这里是将参数放入Body中，如果没有参数传入就默认传入空字符串，生成payload
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>query) {
            query <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;&#34;</span>;
        }
      	<span style="color:#75715e">// 这里的请求是排除了（GET，HEAD，DELETE）的方式，因此没有写入content-type的话会默认设置header为表单提交方式
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[mutableRequest valueForHTTPHeaderField:<span style="color:#e6db74">@&#34;Content-Type&#34;</span>]) {
            [mutableRequest setValue:<span style="color:#e6db74">@&#34;application/x-www-form-urlencoded&#34;</span> forHTTPHeaderField:<span style="color:#e6db74">@&#34;Content-Type&#34;</span>];
        }
        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];
    }

    <span style="color:#66d9ef">return</span> mutableRequest;
}
</code></pre></div><p>除此之外还有其他特殊的处理，比如对请求体的分界线处理等，这里不过多叙述</p>
<p>下面来看对请求结果的序列化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#75715e">// 使用并行队列对响应进行处理，提升解析效率
</span><span style="color:#75715e"></span>dispatch_async(url_session_manager_processing_queue(), <span style="color:#f92672">^</span>{
  NSError <span style="color:#f92672">*</span>serializationError <span style="color:#f92672">=</span> nil;
  responseObject <span style="color:#f92672">=</span> [manager.responseSerializer responseObjectForResponse:task.response data:data error:<span style="color:#f92672">&amp;</span>serializationError];

  <span style="color:#66d9ef">if</span> (self.downloadFileURL) {
    responseObject <span style="color:#f92672">=</span> self.downloadFileURL;
  }

  <span style="color:#66d9ef">if</span> (responseObject) {
    userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] <span style="color:#f92672">=</span> responseObject;
  }

  <span style="color:#66d9ef">if</span> (serializationError) {
    userInfo[AFNetworkingTaskDidCompleteErrorKey] <span style="color:#f92672">=</span> serializationError;
  }

  <span style="color:#75715e">// 处理完成后还是GCD统一处理
</span><span style="color:#75715e"></span>  dispatch_group_async(manager.completionGroup <span style="color:#f92672">?:</span> url_session_manager_completion_group(), manager.completionQueue <span style="color:#f92672">?:</span> dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">if</span> (self.completionHandler) {
      self.completionHandler(task.response, responseObject, serializationError);
    }
		<span style="color:#75715e">// 发出通知
</span><span style="color:#75715e"></span>    dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
      [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
    });
  });
});
</code></pre></div><p>接下来看 <strong>AFJSONResponseSerializer</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">responseObjectForResponse:</span>(NSURLResponse <span style="color:#f92672">*</span>)response
                           <span style="color:#a6e22e">data:</span>(NSData <span style="color:#f92672">*</span>)data
                          <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">*</span><span style="color:#66d9ef">__autoreleasing</span> <span style="color:#f92672">*</span>)error
{
		<span style="color:#75715e">// 第一步永远是校验数据合法性，这种编程习惯值得我们学习，实现功能的同时首先要考虑错误和非法输入
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[self validateResponse:(NSHTTPURLResponse <span style="color:#f92672">*</span>)response data:data error:error]) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>error <span style="color:#f92672">||</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span style="color:#f92672">*</span>error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
            <span style="color:#66d9ef">return</span> nil;
        }
    }

    <span style="color:#75715e">// 检查body是否为空格，对应rails的一种处理方式
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">BOOL</span> isSpace <span style="color:#f92672">=</span> [data isEqualToData:[NSData dataWithBytes:<span style="color:#e6db74">&#34; &#34;</span> length:<span style="color:#ae81ff">1</span>]];
    
    <span style="color:#66d9ef">if</span> (data.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> isSpace) {
        <span style="color:#66d9ef">return</span> nil;
    }
    
    NSError <span style="color:#f92672">*</span>serializationError <span style="color:#f92672">=</span> nil;
    <span style="color:#75715e">// 真正解析json的地方
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">id</span> responseObject <span style="color:#f92672">=</span> [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:<span style="color:#f92672">&amp;</span>serializationError];

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>responseObject)
    {
        <span style="color:#66d9ef">if</span> (error) {
            <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> AFErrorWithUnderlyingError(serializationError, <span style="color:#f92672">*</span>error);
        }
        <span style="color:#66d9ef">return</span> nil;
    }
    
		<span style="color:#75715e">// 移除json解析出来的null对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (self.removesKeysWithNullValues) 
        <span style="color:#66d9ef">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
    }

    <span style="color:#66d9ef">return</span> responseObject;
}
</code></pre></div><p>json解析就到这里了，主要能看出框架作者编程的模块化、安全编程等优秀的习惯</p>
<h3 id="安全策略部分-afsecuritypolicy">安全策略部分 AFSecurityPolicy</h3>
<p><strong>AFHTTPSessionManager</strong> 在初始化的时候使用了默认的安全策略  <code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code> ，下面我们来研究下安全策略是干什么用的</p>
<p>我们都知道网络请求有非加密链接，在用浏览器打开一些杂七杂八的网站的时候，总会提示你当前的连接不安全，也即是说，如果你的网络请求没有使用 <strong>ssl</strong> 或 <strong>tls</strong> 加密算法加密，<a href="https://k.felixplus.top/https/">这一部分可以看这篇博客</a> ，当然，如果我们请求的服务使用了非自签名证书，并且该CA是默认被内置在苹果中的话我们是不需要额外配置什么东西的，但是事情总有例外，有些业务方出于一些需求需要使用自签名证书，这就需要我们配置 <strong>AFSecurityPolicy</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">+ (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">defaultPolicy</span> {
    AFSecurityPolicy <span style="color:#f92672">*</span>securityPolicy <span style="color:#f92672">=</span> [[self alloc] init];
    securityPolicy.SSLPinningMode <span style="color:#f92672">=</span> AFSSLPinningModeNone;

    <span style="color:#66d9ef">return</span> securityPolicy;
}
</code></pre></div><p>可以看到这里使用默认的配置 <strong>AFSSLPinningModeNone</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">NS_ENUM</span>(NSUInteger, AFSSLPinningMode) {
    AFSSLPinningModeNone, 				<span style="color:#75715e">// 只验证iOS系统内置的证书
</span><span style="color:#75715e"></span>    AFSSLPinningModePublicKey,		<span style="color:#75715e">// 验证服务下发的证书(与本地证书)，仅对比公钥
</span><span style="color:#75715e"></span>    AFSSLPinningModeCertificate,	<span style="color:#75715e">// 验证服务下发的证书(与本地证书)，会先验证域名和有效期等信息
</span><span style="color:#75715e"></span>};
</code></pre></div><p>对于获取服务器的公钥你可以使用以下命令</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">openssl s_client -showcerts -connect www.bing.com:443 &lt;/dev/null | openssl x509 -outform DER &gt; server.cer
</code></pre></div><p>接下来将你所需要使用服务的公钥加入工程中，使用的时候可以如下配置</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">AFSecurityPolicy <span style="color:#f92672">*</span>policy <span style="color:#f92672">=</span> [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];

manager.securityPolicy <span style="color:#f92672">=</span> policy;
</code></pre></div><p>你可能会问，这里我们也没有指定证书啊，放心，我们看方法体</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c">+ (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">policyWithPinningMode:</span>(AFSSLPinningMode)pinningMode {
  	<span style="color:#75715e">// 这个初始化方法里面传入了证书
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];
}

<span style="color:#75715e">// 会从当前的类被加载的bundle中获取
</span><span style="color:#75715e"></span>+ (NSSet <span style="color:#f92672">*</span>)<span style="color:#a6e22e">defaultPinnedCertificates</span> {
    <span style="color:#66d9ef">static</span> NSSet <span style="color:#f92672">*</span>_defaultPinnedCertificates <span style="color:#f92672">=</span> nil;
    <span style="color:#66d9ef">static</span> dispatch_once_t onceToken;
    dispatch_once(<span style="color:#f92672">&amp;</span>onceToken, <span style="color:#f92672">^</span>{
        NSBundle <span style="color:#f92672">*</span>bundle <span style="color:#f92672">=</span> [NSBundle bundleForClass:[self <span style="color:#66d9ef">class</span>]];
        _defaultPinnedCertificates <span style="color:#f92672">=</span> [self certificatesInBundle:bundle];
    });

    <span style="color:#66d9ef">return</span> _defaultPinnedCertificates;
}

<span style="color:#75715e">// 获取所有以.cer结尾的文件
</span><span style="color:#75715e"></span>+ (NSSet <span style="color:#f92672">*</span>)<span style="color:#a6e22e">certificatesInBundle:</span>(NSBundle <span style="color:#f92672">*</span>)bundle {
    NSArray <span style="color:#f92672">*</span>paths <span style="color:#f92672">=</span> [bundle pathsForResourcesOfType:<span style="color:#e6db74">@&#34;cer&#34;</span> inDirectory:<span style="color:#e6db74">@&#34;.&#34;</span>];

    NSMutableSet <span style="color:#f92672">*</span>certificates <span style="color:#f92672">=</span> [NSMutableSet setWithCapacity:[paths count]];
    <span style="color:#66d9ef">for</span> (NSString <span style="color:#f92672">*</span>path <span style="color:#66d9ef">in</span> paths) {
        NSData <span style="color:#f92672">*</span>certificateData <span style="color:#f92672">=</span> [NSData dataWithContentsOfFile:path];
        [certificates addObject:certificateData];
    }

    <span style="color:#66d9ef">return</span> [NSSet setWithSet:certificates];
}
</code></pre></div><h2 id="永远对代码有敬畏之心">永远对代码有敬畏之心</h2>
<p>很多人可能觉得写一个网络请求很简单，随随便便就能完成，可是不要忘了，在软件开发过程中开发只是第一步，而且不是权重最大的一部，如果你的代码模块复杂，逻辑混乱不堪那么在后续的维护中就会相当复杂，我上面总结了那么多的使用模块在外面的调用不过是一行 <code>[[AFHTTPSessionManager manager] GET:@&quot;http://httpbin.org/get&quot; parameters:nil progress:nil success:nil failure:nil]</code> 这么简单。在提升自己的路上，我们做的还有很多</p>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">Posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/tags/objc/">Arithmetic</a>
        
            &#183; 
            <a href="http://example.org/about">Who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog. <a href="mailto:cb7d23@gmail.com">cb7d23@gmail.com</a></div>
    </div>
</body>

</html>