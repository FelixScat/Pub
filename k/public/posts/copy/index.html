<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Cb7d &#39;s blog">
<title>
浅谈 ObjC 中的几种copy - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="浅谈 ObjC 中的几种copy"/>
<meta name="twitter:description" content="Copy 拷贝是我们在开发中经常使用的技巧，这里指的不是到Github上去复制粘贴代码，而是对内存中对象的操作 (逃
 深拷贝与浅拷贝的区别 ？ 深拷贝是指我们拷贝出来的对象拥有自己单独的内存地址，修改新对象不影响源对象，浅拷贝指的是在copy指针的引用，修改新对象会影响到源对象
 在ObjC里面主要有两个方法对对象进行拷贝
- (id)copy; - (id)mutableCopy; 要对象能够使用这两个方法需要遵守协议 NSCopying, NSMutableCopying
那么，该何时使用这两种方法呢， 先说结论，只有不可变对象调用copy方法的时候才是浅拷贝，其他情况均为深拷贝 新建一个工程验证一下吧
Xcode -&gt; New -&gt; MacOS -&gt; CommandLine -&gt; main.m
由于NSString 同时实现了 NSCopying, NSMutableCopying 两个协议，我们就用他来做实验
NSString *str1 = @&#34;str1&#34;; NSString *str2 = str1.copy; NSString *str3 = str1.mutableCopy; NSLog(@&#34;%p %p %p&#34;,str1, str2, str3); 运行之后可以看到如下输出
0x1000020b8 0x1000020b8 0x100508e00 由此可以得出结论，不可变对象使用 mutableCopy 为深拷贝 ，copy 为浅拷贝
下面验证一下可变对象 NSMutableString
NSMutableString *str1 = [NSMutableString stringWithFormat:@&#34;str1&#34;]; NSString *str2 = str1.copy; NSString *str3 = str1."/>

<meta property="og:title" content="浅谈 ObjC 中的几种copy" />
<meta property="og:description" content="Copy 拷贝是我们在开发中经常使用的技巧，这里指的不是到Github上去复制粘贴代码，而是对内存中对象的操作 (逃
 深拷贝与浅拷贝的区别 ？ 深拷贝是指我们拷贝出来的对象拥有自己单独的内存地址，修改新对象不影响源对象，浅拷贝指的是在copy指针的引用，修改新对象会影响到源对象
 在ObjC里面主要有两个方法对对象进行拷贝
- (id)copy; - (id)mutableCopy; 要对象能够使用这两个方法需要遵守协议 NSCopying, NSMutableCopying
那么，该何时使用这两种方法呢， 先说结论，只有不可变对象调用copy方法的时候才是浅拷贝，其他情况均为深拷贝 新建一个工程验证一下吧
Xcode -&gt; New -&gt; MacOS -&gt; CommandLine -&gt; main.m
由于NSString 同时实现了 NSCopying, NSMutableCopying 两个协议，我们就用他来做实验
NSString *str1 = @&#34;str1&#34;; NSString *str2 = str1.copy; NSString *str3 = str1.mutableCopy; NSLog(@&#34;%p %p %p&#34;,str1, str2, str3); 运行之后可以看到如下输出
0x1000020b8 0x1000020b8 0x100508e00 由此可以得出结论，不可变对象使用 mutableCopy 为深拷贝 ，copy 为浅拷贝
下面验证一下可变对象 NSMutableString
NSMutableString *str1 = [NSMutableString stringWithFormat:@&#34;str1&#34;]; NSString *str2 = str1.copy; NSString *str3 = str1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/copy/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2018-06-19T10:46:42+08:00" />
<meta property="article:modified_time" content="2018-06-19T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d &#39;s blog" />


    

    
    
    
    <title>
        
        浅谈 ObjC 中的几种copy
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">浅谈 ObjC 中的几种copy</div>

        
<div class="section" id="content">
    Tue Jun 19, 2018 &#183; 422 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/memory/">
                memory
            </a>
        </span>
        
        
    </div>
    <hr/>
    <h1 id="copy">Copy</h1>
<p>拷贝是我们在开发中经常使用的技巧，这里指的不是到Github上去复制粘贴代码，而是对内存中对象的操作 (逃</p>
<blockquote>
<p>深拷贝与浅拷贝的区别 ？ 深拷贝是指我们拷贝出来的对象拥有自己单独的内存地址，修改新对象不影响源对象，浅拷贝指的是在copy指针的引用，修改新对象会影响到源对象</p>
</blockquote>
<p>在ObjC里面主要有两个方法对对象进行拷贝</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">copy</span>;
- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">mutableCopy</span>;
</code></pre></div><p>要对象能够使用这两个方法需要遵守协议 NSCopying, NSMutableCopying</p>
<p>那么，该何时使用这两种方法呢，
先说结论，只有不可变对象调用copy方法的时候才是浅拷贝，其他情况均为深拷贝
新建一个工程验证一下吧</p>
<p>Xcode -&gt; New -&gt; MacOS -&gt; CommandLine -&gt; main.m</p>
<p>由于NSString 同时实现了 NSCopying, NSMutableCopying 两个协议，我们就用他来做实验</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSString <span style="color:#f92672">*</span>str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;str1&#34;</span>;
NSString <span style="color:#f92672">*</span>str2 <span style="color:#f92672">=</span> str1.<span style="color:#66d9ef">copy</span>;
NSString <span style="color:#f92672">*</span>str3 <span style="color:#f92672">=</span> str1.mutableCopy;

NSLog(<span style="color:#e6db74">@&#34;%p %p %p&#34;</span>,str1, str2, str3);
</code></pre></div><p>运行之后可以看到如下输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#ae81ff">0x1000020b8</span> <span style="color:#ae81ff">0x1000020b8</span> <span style="color:#ae81ff">0x100508e00</span>
</code></pre></div><p>由此可以得出结论，不可变对象使用 mutableCopy 为深拷贝 ，copy 为浅拷贝</p>
<p>下面验证一下可变对象 NSMutableString</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSMutableString <span style="color:#f92672">*</span>str1 <span style="color:#f92672">=</span> [NSMutableString stringWithFormat:<span style="color:#e6db74">@&#34;str1&#34;</span>];
NSString <span style="color:#f92672">*</span>str2 <span style="color:#f92672">=</span> str1.<span style="color:#66d9ef">copy</span>;
NSString <span style="color:#f92672">*</span>str3 <span style="color:#f92672">=</span> str1.mutableCopy;

NSLog(<span style="color:#e6db74">@&#34;%p %p %p&#34;</span>,str1, str2, str3);

<span style="color:#ae81ff">0x100505260</span> <span style="color:#ae81ff">0x50602036b4ec25f</span> <span style="color:#ae81ff">0x100505290</span>
</code></pre></div><p>得出结论，可变对象无论使用 copy 还是 mutableCopy ，均为深拷贝</p>
<p>这些是非集合类型的拷贝结论，那么对于集合类型来说呢</p>
<p>新建Person类</p>
<p>Person.h</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#import &lt;Foundation/Foundation.h&gt;
</span><span style="color:#75715e"></span>
NS_ASSUME_NONNULL_BEGIN

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Person</span> : <span style="color:#a6e22e">NSObject</span>

<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span> ,<span style="color:#66d9ef">copy</span>) NSString <span style="color:#f92672">*</span>name;

<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span> ,<span style="color:#66d9ef">assign</span>) NSUInteger age;

<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span> ,<span style="color:#66d9ef">copy</span>) NSArray<span style="color:#f92672">&lt;</span>Person <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">*</span>friends;

<span style="color:#66d9ef">@end</span>

NS_ASSUME_NONNULL_END

</code></pre></div><p>Person.m</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#import &#34;Person.h&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    
    self <span style="color:#f92672">=</span> [super init];
    
    <span style="color:#66d9ef">if</span> (self) {
        _name <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;&#34;</span>;
        _age <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        _friends <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[]</span>;
    }
    
    <span style="color:#66d9ef">return</span> self;
}

<span style="color:#75715e">// 重写以便打印对象的属性
</span><span style="color:#75715e"></span>- (NSString <span style="color:#f92672">*</span>)<span style="color:#a6e22e">description</span> {
    
    <span style="color:#66d9ef">return</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;- name: %@, age: %ld, friends: %@&#34;</span>,self.name, self.age, self.friends];
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>如果正常按照上面的来想，集合类型应该也是一样 只有不可变对象调用copy方法的时候才是浅拷贝，其他情况均为深拷贝</p>
<p>下面创建Array来验证想法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Person <span style="color:#f92672">*</span>Alice <span style="color:#f92672">=</span> Person.new;
Alice.name <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;Alice&#34;</span>;
Alice.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;

NSArray <span style="color:#f92672">*</span>arr1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[</span>Alice<span style="color:#ae81ff">]</span>;
NSArray <span style="color:#f92672">*</span>arr2 <span style="color:#f92672">=</span> arr1.<span style="color:#66d9ef">copy</span>;
NSArray <span style="color:#f92672">*</span>arr3 <span style="color:#f92672">=</span> arr1.mutableCopy;

NSLog(<span style="color:#e6db74">@&#34;%p %p %p&#34;</span>,arr1, arr2, arr3);

<span style="color:#ae81ff">0x1030064c0</span> <span style="color:#ae81ff">0x1030064c0</span> <span style="color:#ae81ff">0x103004a90</span>
</code></pre></div><p>NSArray吻合我们上面的结论，下面看下NSMutableArray</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Person <span style="color:#f92672">*</span>Alice <span style="color:#f92672">=</span> Person.new;
Alice.name <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;Alice&#34;</span>;
Alice.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;

NSMutableArray <span style="color:#f92672">*</span>arr1 <span style="color:#f92672">=</span> [NSMutableArray arrayWithArray:<span style="color:#ae81ff">@[</span>Alice<span style="color:#ae81ff">]</span>];
NSArray <span style="color:#f92672">*</span>arr2 <span style="color:#f92672">=</span> arr1.<span style="color:#66d9ef">copy</span>;
NSArray <span style="color:#f92672">*</span>arr3 <span style="color:#f92672">=</span> arr1.mutableCopy;

NSLog(<span style="color:#e6db74">@&#34;%p %p %p&#34;</span>,arr1, arr2, arr3);

<span style="color:#ae81ff">0x1030051f0</span> <span style="color:#ae81ff">0x103006a00</span> <span style="color:#ae81ff">0x1030054a0</span>
</code></pre></div><p>也温和上面的结论，但是稍等</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSMutableArray <span style="color:#f92672">*</span>arr1 <span style="color:#f92672">=</span> [NSMutableArray arrayWithArray:<span style="color:#ae81ff">@[</span>Alice<span style="color:#ae81ff">]</span>];
NSArray <span style="color:#f92672">*</span>arr2 <span style="color:#f92672">=</span> arr1.<span style="color:#66d9ef">copy</span>;

NSLog(<span style="color:#e6db74">@&#34;%p %p&#34;</span>,arr1.firstObject, arr2.firstObject);
</code></pre></div><p>我们可以打印arr1 和 arr2 的第一个元素的地址，发现他们还是指向同一个地址！</p>
<p>查看Apple关于<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3" title="DeepCopy">DeepCopy</a>的文档</p>
<p>我们发现，原来要对一个集合类型实现真正的深拷贝需要用这种方法, 而上面这种官方名称为【单层深拷贝】</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSArray<span style="color:#f92672">*</span> trueDeepCopyArray <span style="color:#f92672">=</span> [NSKeyedUnarchiver unarchiveObjectWithData:
[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
</code></pre></div><p>好，那么我们来改造代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Person <span style="color:#f92672">*</span>Alice <span style="color:#f92672">=</span> Person.new;
Alice.name <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;Alice&#34;</span>;
Alice.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;

NSError <span style="color:#f92672">*</span>err;

NSMutableArray <span style="color:#f92672">*</span>arr1 <span style="color:#f92672">=</span> [NSMutableArray arrayWithArray:<span style="color:#ae81ff">@[</span>Alice<span style="color:#ae81ff">]</span>];
NSArray <span style="color:#f92672">*</span>arr2 <span style="color:#f92672">=</span> [NSKeyedUnarchiver unarchivedObjectOfClass:[NSArray <span style="color:#66d9ef">class</span>] fromData:[NSKeyedArchiver archivedDataWithRootObject:arr1 requiringSecureCoding:false error:<span style="color:#f92672">&amp;</span>err] error:<span style="color:#f92672">&amp;</span>err];

<span style="color:#66d9ef">if</span> (err) {
    NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>,err);
}

NSLog(<span style="color:#e6db74">@&#34;%p %p&#34;</span>,arr1.firstObject, arr2.firstObject);
</code></pre></div><p>奇怪的是输出arr2为nil，看一下控制台输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#f92672">-</span>[Person encodeWithCoder:]<span style="color:#f92672">:</span> unrecognized selector sent to instance <span style="color:#ae81ff">0x100706ac0</span>
</code></pre></div><p>原来是我们的Person没有遵守协议 NSCoding , 除此之外我们还需要遵守 NSSecureCoding 协议</p>
<p>改造后的Person.m</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#import &#34;Person.h&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Person</span> () <span style="color:#f92672">&lt;</span>NSCoding, NSSecureCoding<span style="color:#f92672">&gt;</span>

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>

+ (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">supportsSecureCoding</span> {
    <span style="color:#66d9ef">return</span> true;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">encodeWithCoder:</span>(NSCoder <span style="color:#f92672">*</span>)aCoder {
    
    [aCoder encodeObject:_name forKey:<span style="color:#e6db74">@&#34;name&#34;</span>];
    [aCoder encodeInteger:_age forKey:<span style="color:#e6db74">@&#34;age&#34;</span>];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithCoder:</span>(NSCoder <span style="color:#f92672">*</span>)aDecoder {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        self.name <span style="color:#f92672">=</span> [aDecoder decodeObjectForKey:<span style="color:#e6db74">@&#34;name&#34;</span>];
        self.age <span style="color:#f92672">=</span> [aDecoder decodeIntegerForKey:<span style="color:#e6db74">@&#34;age&#34;</span>];
    }
    <span style="color:#66d9ef">return</span> self;
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    
    self <span style="color:#f92672">=</span> [super init];
    
    <span style="color:#66d9ef">if</span> (self) {
        _name <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;&#34;</span>;
        _age <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        _friends <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[]</span>;
    }
    
    <span style="color:#66d9ef">return</span> self;
}

</code></pre></div><p>现在我们打开main.m试一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Person <span style="color:#f92672">*</span>Alice <span style="color:#f92672">=</span> Person.new;
Alice.name <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;Alice&#34;</span>;
Alice.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;

NSError <span style="color:#f92672">*</span>err;

NSMutableArray <span style="color:#f92672">*</span>arr1 <span style="color:#f92672">=</span> [NSMutableArray arrayWithArray:<span style="color:#ae81ff">@[</span>Alice<span style="color:#ae81ff">]</span>];
NSArray <span style="color:#f92672">*</span>arr2 <span style="color:#f92672">=</span> [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSArray <span style="color:#66d9ef">class</span>],[Person <span style="color:#66d9ef">class</span>], nil] fromData:[NSKeyedArchiver archivedDataWithRootObject:arr1 requiringSecureCoding:true error:<span style="color:#f92672">&amp;</span>err] error:<span style="color:#f92672">&amp;</span>err];

<span style="color:#66d9ef">if</span> (err) {
    NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>,err);
}

NSLog(<span style="color:#e6db74">@&#34;%p %p&#34;</span>,arr1.firstObject, arr2.firstObject);

<span style="color:#ae81ff">0x100709880</span> <span style="color:#ae81ff">0x100705c60</span>
</code></pre></div><p>我们发现数组里面的对象地址也全都不一样了，这才是集合类型的真正深拷贝</p>
<p>thanks.</p>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">Posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/tags/objc/">Arithmetic</a>
        
            &#183; 
            <a href="http://example.org/about">Who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog. <a href="mailto:cb7d23@gmail.com">cb7d23@gmail.com</a></div>
    </div>
</body>

</html>