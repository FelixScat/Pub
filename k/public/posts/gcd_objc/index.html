<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Cb7d &#39;s blog">
<title>
GCD (ObjC) - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="GCD (ObjC)"/>
<meta name="twitter:description" content="Grand Central Dispatch 这篇文主要想总结下 GCD 在ObjC中的使用，文中示例代码
基本概念 进程 进程指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体
线程 线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。
队列 队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。
同步/异步 可以这么理解：
假如你要做两件事 ， 烧水 、 刷牙
 同步 ：你烧水 ， 等水烧开了你再去刷牙 异步 ：你烧水 ，不等水烧开就去刷牙了 ， 水烧开了会发出声音告诉你（callback） ， 然后你再处理水烧开之后的事情  只要你是个正常人 ， 都会选择第二种 ，当然也有特殊情况 ，你喜欢用热水刷牙
并发 指两个或多个事件在同一时间间隔内发生。可以在某条线程和其他线程之间反复多次进行上下文切换，看上去就好像一个CPU能够并且执行多个线程一样。其实是伪异步。
线程队列中并行/串行 串行队列：串行队列的特点是队列内的线程是一个一个执行，直到结束。并行队列：并行队列的特点是队列中所有线程的执行结束时必须是一块的，队列中其他线程执行完毕后，会阻塞当前线程等待队列中其他线程执行，然后一块执行完毕。
 开始 下面我们就用刷牙与烧水来举例，首先clone工程，本文工程Demo
git clone https://github.com/FelixScat/demo_GCD.git cd ObjCGCD xed ./ 打开main.m先声明两个事件
int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here...  // 烧水  void (^boiledWater)(void) = ^(void){ NSLog(@&#34;开始烧水：%@&#34;, [NSThread currentThread]); sleep(3); NSLog(@&#34;水烧好啦&#34;); }; // 刷牙  void (^brushTeeth)(void) = ^(void){ NSLog(@&#34;开始刷牙：%@&#34;, [NSThread currentThread]); sleep(5); NSLog(@&#34;牙刷完啦&#34;); }; NSLog(@&#34;Enter (q) to quit\n&#34;); char input[100]; while (scanf(&#34;%[^\n]%*c&#34;, input)) { NSString *str = [NSString stringWithCString:input encoding:NSUTF8StringEncoding]; if ([str isEqualToString:@&#34;q&#34;]) { exit(0); } } } return 0; } 队列 先声明两个队列 // 串行队列 dispatch_queue_t serialQueue = dispatch_queue_create(&#34;top."/>

<meta property="og:title" content="GCD (ObjC)" />
<meta property="og:description" content="Grand Central Dispatch 这篇文主要想总结下 GCD 在ObjC中的使用，文中示例代码
基本概念 进程 进程指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体
线程 线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。
队列 队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。
同步/异步 可以这么理解：
假如你要做两件事 ， 烧水 、 刷牙
 同步 ：你烧水 ， 等水烧开了你再去刷牙 异步 ：你烧水 ，不等水烧开就去刷牙了 ， 水烧开了会发出声音告诉你（callback） ， 然后你再处理水烧开之后的事情  只要你是个正常人 ， 都会选择第二种 ，当然也有特殊情况 ，你喜欢用热水刷牙
并发 指两个或多个事件在同一时间间隔内发生。可以在某条线程和其他线程之间反复多次进行上下文切换，看上去就好像一个CPU能够并且执行多个线程一样。其实是伪异步。
线程队列中并行/串行 串行队列：串行队列的特点是队列内的线程是一个一个执行，直到结束。并行队列：并行队列的特点是队列中所有线程的执行结束时必须是一块的，队列中其他线程执行完毕后，会阻塞当前线程等待队列中其他线程执行，然后一块执行完毕。
 开始 下面我们就用刷牙与烧水来举例，首先clone工程，本文工程Demo
git clone https://github.com/FelixScat/demo_GCD.git cd ObjCGCD xed ./ 打开main.m先声明两个事件
int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here...  // 烧水  void (^boiledWater)(void) = ^(void){ NSLog(@&#34;开始烧水：%@&#34;, [NSThread currentThread]); sleep(3); NSLog(@&#34;水烧好啦&#34;); }; // 刷牙  void (^brushTeeth)(void) = ^(void){ NSLog(@&#34;开始刷牙：%@&#34;, [NSThread currentThread]); sleep(5); NSLog(@&#34;牙刷完啦&#34;); }; NSLog(@&#34;Enter (q) to quit\n&#34;); char input[100]; while (scanf(&#34;%[^\n]%*c&#34;, input)) { NSString *str = [NSString stringWithCString:input encoding:NSUTF8StringEncoding]; if ([str isEqualToString:@&#34;q&#34;]) { exit(0); } } } return 0; } 队列 先声明两个队列 // 串行队列 dispatch_queue_t serialQueue = dispatch_queue_create(&#34;top." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/gcd_objc/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2019-03-25T10:46:42+08:00" />
<meta property="article:modified_time" content="2019-03-25T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d &#39;s blog" />


    

    
    
    
    <title>
        
        GCD (ObjC)
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">GCD (ObjC)</div>

        
<div class="section" id="content">
    Mon Mar 25, 2019 &#183; 435 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/thread/">
                Thread
            </a>
        </span>
        
        
    </div>
    <hr/>
    <h1 id="grand-central-dispatch">Grand Central Dispatch</h1>
<p>这篇文主要想总结下 <code>GCD</code> 在<code>ObjC</code>中的使用，<a href="https://github.com/FelixScat/demo_GCD">文中示例代码</a></p>
<h2 id="基本概念">基本概念</h2>
<h3 id="进程">进程</h3>
<p>进程指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体</p>
<h3 id="线程">线程</h3>
<p>线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。</p>
<h3 id="队列">队列</h3>
<p>队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<h3 id="同步异步">同步/异步</h3>
<p>可以这么理解：</p>
<p>假如你要做两件事 ， 烧水 、 刷牙</p>
<ul>
<li>同步 ：你烧水 ， 等水烧开了你再去刷牙</li>
<li>异步 ：你烧水 ，不等水烧开就去刷牙了 ， 水烧开了会发出声音告诉你（callback） ， 然后你再处理水烧开之后的事情</li>
</ul>
<p><strong>只要你是个正常人 ， 都会选择第二种 ，当然也有特殊情况 ，你喜欢用热水刷牙</strong></p>
<h3 id="并发">并发</h3>
<p>指两个或多个事件在同一时间间隔内发生。可以在某条线程和其他线程之间反复多次进行上下文切换，看上去就好像一个CPU能够并且执行多个线程一样。其实是伪异步。</p>
<h3 id="线程队列中并行串行">线程队列中并行/串行</h3>
<p>串行队列：串行队列的特点是队列内的线程是一个一个执行，直到结束。并行队列：并行队列的特点是队列中所有线程的执行结束时必须是一块的，队列中其他线程执行完毕后，会阻塞当前线程等待队列中其他线程执行，然后一块执行完毕。</p>
<hr>
<h2 id="开始">开始</h2>
<p>下面我们就用刷牙与烧水来举例，首先clone工程，<a href="https://github.com/FelixScat/demo_GCD">本文工程Demo</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">git clone https://github.com/FelixScat/demo_GCD.git
cd ObjCGCD
xed ./
</code></pre></div><p>打开<code>main.m</code>先声明两个事件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#75715e">// insert code here...
</span><span style="color:#75715e"></span>        
        <span style="color:#75715e">// 烧水
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>boiledWater)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">void</span>){
            NSLog(<span style="color:#e6db74">@&#34;开始烧水：%@&#34;</span>, [NSThread currentThread]);
            sleep(<span style="color:#ae81ff">3</span>);
            NSLog(<span style="color:#e6db74">@&#34;水烧好啦&#34;</span>);
        };
        
        <span style="color:#75715e">// 刷牙
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>brushTeeth)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">void</span>){
            NSLog(<span style="color:#e6db74">@&#34;开始刷牙：%@&#34;</span>, [NSThread currentThread]);
            sleep(<span style="color:#ae81ff">5</span>);
            NSLog(<span style="color:#e6db74">@&#34;牙刷完啦&#34;</span>);
        };
        
        NSLog(<span style="color:#e6db74">@&#34;Enter (q) to quit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">char</span> input[<span style="color:#ae81ff">100</span>];
        <span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74">&#34;%[^</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">]%*c&#34;</span>, input)) {
            NSString <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> [NSString stringWithCString:input encoding:NSUTF8StringEncoding];
            <span style="color:#66d9ef">if</span> ([str isEqualToString:<span style="color:#e6db74">@&#34;q&#34;</span>]) {
                exit(<span style="color:#ae81ff">0</span>);
            }
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h3 id="队列-1">队列</h3>
<h4 id="先声明两个队列">先声明两个队列</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="color:#75715e">// 串行队列
</span><span style="color:#75715e"></span>dispatch_queue_t serialQueue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;top.felixplus.k.serial&#34;</span>, <span style="color:#ae81ff">0</span>);
<span style="color:#75715e">// 并行队列
</span><span style="color:#75715e"></span>dispatch_queue_t concurrentQueue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;top.felixplus.k.concurrent&#34;</span>, DISPATCH_QUEUE_CONCURRENT);
</code></pre></div><p>其中串行队列就表示队列中的人物会依次执行，而并行队列中的人物将会同时并发执行</p>
<h3 id="同步任务">同步任务</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_sync(serialQueue, <span style="color:#f92672">^</span>{
  boiledWater();
  brushTeeth();
});
</code></pre></div><p>串行就会一个任务接着一个任务执行，最终输入如下</p>
<pre><code>2019-08-26 15:04:54.199599+0800 ObjCGCD[10282:1329591] 开始烧水：&lt;NSThread: 0x100503ba0&gt;{number = 1, name = main}
2019-08-26 15:04:57.204298+0800 ObjCGCD[10282:1329591] 水烧好啦
2019-08-26 15:04:57.204523+0800 ObjCGCD[10282:1329591] 开始刷牙：&lt;NSThread: 0x100503ba0&gt;{number = 1, name = main}
2019-08-26 15:05:02.204803+0800 ObjCGCD[10282:1329591] 牙刷完啦
2019-08-26 15:05:02.204866+0800 ObjCGCD[10282:1329591] Enter (q) to quit
</code></pre><p>使用sync是没有开辟新线程的能力的，同时，同步任务执行的线程必然为sync代码执行上下文的线程</p>
<p>可以看到log中的输出是在mainthread。</p>
<h3 id="异步任务">异步任务</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), boiledWater);
dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), brushTeeth);
</code></pre></div><p>并行任务几乎会同时开始，同时进行，下面是输出</p>
<pre><code>2019-08-26 15:06:52.401411+0800 ObjCGCD[12001:1337448] Enter (q) to quit
2019-08-26 15:06:52.401708+0800 ObjCGCD[12001:1337471] 开始烧水：&lt;NSThread: 0x1030280f0&gt;{number = 2, name = (null)}
2019-08-26 15:06:52.401720+0800 ObjCGCD[12001:1337472] 开始刷牙：&lt;NSThread: 0x100503fa0&gt;{number = 3, name = (null)}
2019-08-26 15:06:55.403434+0800 ObjCGCD[12001:1337471] 水烧好啦
2019-08-26 15:06:57.402995+0800 ObjCGCD[12001:1337472] 牙刷完啦
</code></pre><p>异步任务也不一定就一定会开启新的线程，具体的操作会由GCD内部负责处理，可以尝试以下测试代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000</span>; i<span style="color:#f92672">++</span>) {
	dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), boiledWater);
}
</code></pre></div><h3 id="优先级qos">优先级QOS</h3>
<p>队列在执行的时候有优先级的区别，更高的优先级会得到更优先调用顺序</p>
<ul>
<li>User Interactive： 和用户交互相关，比如动画等等优先级最高。比如用户连续拖拽的计算</li>
<li>User Initiated： 需要立刻的结果，比如push一个ViewController之前的数据计算</li>
<li>Utility： 可以执行很长时间，再通知用户结果。比如下载一个文件，给用户下载进度。</li>
<li>Background： 用户不可见，比如在后台存储大量数据</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_queue_attr_t serial_attr <span style="color:#f92672">=</span> dispatch_queue_attr_make_with_qos_class (DISPATCH_QUEUE_SERIAL, QOS_CLASS_DEFAULT,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
dispatch_queue_attr_t concurrent_attr <span style="color:#f92672">=</span> dispatch_queue_attr_make_with_qos_class (DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_DEFAULT,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        
<span style="color:#75715e">// 串行队列
</span><span style="color:#75715e"></span>dispatch_queue_t serialQueue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;top.felixplus.k.serial&#34;</span>, serial_attr);
<span style="color:#75715e">// 并行队列
</span><span style="color:#75715e"></span>dispatch_queue_t concurrentQueue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;top.felixplus.k.concurrent&#34;</span>, concurrent_attr);
</code></pre></div><h3 id="死锁">死锁</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_sync(dispatch_get_main_queue(), boiledWater);
</code></pre></div><p>这段代码一定会造成死锁，那么产生的原因是什么呢</p>
<p>可以先把上面这一整段代码想象成一个任务块(block)，当前是主队列，主队列是串行队列，主队列只有当前的block执行完毕才会执行下一个，上面代码中在一个还没有结束的block中增加了一个任务，并且要阻塞当前的队列优先去执行，所以最终导致了队列阻塞，记住一点，类似上述代码导致死锁的原因并不是线程阻塞，而是队列阻塞</p>
<p>解决方法有很多，根据上述我们所说的队列问题，其实很简单，我们使用自己新建的队列执行就可以避免</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_sync(serialQueue, boiledWater);
</code></pre></div><p>这样代码依然会在mainthread执行，并且不会导致主队列的阻塞</p>
<h3 id="信号量">信号量</h3>
<p>信号量可以在很多场景下使用，初始化信号量需要一个数值，信号量通过wait来将这个数值减1，通过signal方法来将这个数值加1，当信号量的值小于0的时候将会一直等待</p>
<p>举个例子，通过信号量我们可以限制一个并行队列中同时运行的任务数量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_semaphore_t signal <span style="color:#f92672">=</span> dispatch_semaphore_create(<span style="color:#ae81ff">2</span>);

dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);
dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#f92672">^</span>{
  boiledWater();
  dispatch_semaphore_signal(signal);
});

dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);
dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#f92672">^</span>{
  brushTeeth();
  dispatch_semaphore_signal(signal);
});

dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);
dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#f92672">^</span>{
  boiledWater();
  dispatch_semaphore_signal(signal);
});

dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);
dispatch_async(dispatch_get_global_queue(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#f92672">^</span>{
  brushTeeth();
  dispatch_semaphore_signal(signal);
});

</code></pre></div><p>再举个例子，我们可以将一些异步的任务转为同步执行（水烧好再刷牙）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_semaphore_t signal <span style="color:#f92672">=</span> dispatch_semaphore_create(<span style="color:#ae81ff">0</span>);

dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
  boiledWater();
  dispatch_semaphore_signal(signal);
});

dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);

dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
  brushTeeth();
});

</code></pre></div><h3 id="group">Group</h3>
<p>任务组可以用来管理任意的任务，不管他们是来自相同队列还是不同队列，下面是使用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_group_t group <span style="color:#f92672">=</span> dispatch_group_create();

dispatch_group_enter(group);
dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
  boiledWater();
  dispatch_group_leave(group);
});

dispatch_group_enter(group);
dispatch_sync(serialQueue, <span style="color:#f92672">^</span>{
  brushTeeth();
  dispatch_group_leave(group);
});
</code></pre></div><p>在任务完成时发出通知</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_group_notify(group, concurrentQueue, <span style="color:#f92672">^</span>{
  NSLog(<span style="color:#e6db74">@&#34;All done&#34;</span>);
});
</code></pre></div><p>阻塞当前线程直到任务全部完成</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
NSLog(<span style="color:#e6db74">@&#34;All done&#34;</span>);
</code></pre></div><h3 id="栅栏方法">栅栏方法</h3>
<p>栅栏方法顾名思义，会把当前的任务前后加上<strong>围栏</strong></p>
<ul>
<li>执行当前任务需要队列中前面全部的任务执行完毕</li>
<li>需要当前任务执行完毕才会执行后面的函数</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">dispatch_barrier_async(concurrentQueue, boiledWater);
dispatch_barrier_async(concurrentQueue, brushTeeth);
</code></pre></div><h3 id="迭代">迭代</h3>
<p>DispatchQueue为我们提供了一种更加方便的方法来同时执行多个迭代次数的相同任务</p>
<p>当我们有大量细小的重复性的工作的时候可以这么用</p>
<p>比如我们要找到0到100000中所有能被17整除的数字：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc">NSMutableArray <span style="color:#f92672">*</span>list <span style="color:#f92672">=</span> [NSMutableArray arrayWithCapacity:<span style="color:#ae81ff">100001</span>];
NSMutableArray <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> [NSMutableArray arrayWithCapacity:<span style="color:#ae81ff">500</span>];
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100000</span>; i<span style="color:#f92672">++</span>) {
  [list addObject:<span style="color:#ae81ff">@(</span>i<span style="color:#ae81ff">)</span>];
}

dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{

  dispatch_apply(list.count, concurrentQueue, <span style="color:#f92672">^</span>(size_t i) {
    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">17</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
      dispatch_sync(serialQueue, <span style="color:#f92672">^</span>{
        [result addObject:list[i]];
      });
    }
  });

  dispatch_sync(serialQueue, <span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>, result);
  });
});

</code></pre></div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://developer.apple.com/documentation/dispatch">https://developer.apple.com/documentation/dispatch</a></li>
<li><a href="https://stackoverflow.com/questions/23856230/what-is-the-difference-between-gcd-main-queue-and-the-main-thread">https://stackoverflow.com/questions/23856230/what-is-the-difference-between-gcd-main-queue-and-the-main-thread</a></li>
<li><a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform">https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform</a></li>
<li><a href="https://juejin.im/post/5acaea17f265da239a601a01#heading-14">https://juejin.im/post/5acaea17f265da239a601a01#heading-14</a></li>
<li><a href="https://medium.com/@vikasdalvi.29/multitasking-in-ios-using-gcd-b931885a719e">https://medium.com/@vikasdalvi.29/multitasking-in-ios-using-gcd-b931885a719e</a></li>
</ul>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">Posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/tags/objc/">Arithmetic</a>
        
            &#183; 
            <a href="http://example.org/about">Who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog. <a href="mailto:cb7d23@gmail.com">cb7d23@gmail.com</a></div>
    </div>
</body>

</html>