<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="A new Hugo site.">
<title>
iOS 中的锁🔒 - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="iOS 中的锁🔒"/>
<meta name="twitter:description" content="Lock 之前总结了atomic的安全性问题，那么在诸如此类的并发使用资源的情况下该如何保证线程安全呢，这篇主要想总结下各种锁的使用
还使用之前电影院卖票的栗子来说明
Theater.h
@interface Theater : NSObject @property (nonatomic, assign) NSInteger ticketNum; @end main.m
int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here...  Theater *theater = [[Theater alloc] init]; // 定义总票数为2000  theater.ticketNum = 2000; // 并发队列用于卖票  dispatch_queue_t concurrentQueue = dispatch_queue_create(&#34;com.test.example0&#34;, DISPATCH_QUEUE_CONCURRENT); // 将总票数分为4部分分别添加到并发队列执行卖票操作  for (int i = 0; i &lt; 4; i&#43;&#43;) { dispatch_async(concurrentQueue, ^{ for (int i = 0; i &lt; 500; i&#43;&#43;) { theater."/>

<meta property="og:title" content="iOS 中的锁🔒" />
<meta property="og:description" content="Lock 之前总结了atomic的安全性问题，那么在诸如此类的并发使用资源的情况下该如何保证线程安全呢，这篇主要想总结下各种锁的使用
还使用之前电影院卖票的栗子来说明
Theater.h
@interface Theater : NSObject @property (nonatomic, assign) NSInteger ticketNum; @end main.m
int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here...  Theater *theater = [[Theater alloc] init]; // 定义总票数为2000  theater.ticketNum = 2000; // 并发队列用于卖票  dispatch_queue_t concurrentQueue = dispatch_queue_create(&#34;com.test.example0&#34;, DISPATCH_QUEUE_CONCURRENT); // 将总票数分为4部分分别添加到并发队列执行卖票操作  for (int i = 0; i &lt; 4; i&#43;&#43;) { dispatch_async(concurrentQueue, ^{ for (int i = 0; i &lt; 500; i&#43;&#43;) { theater." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/lock/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2020-02-19T10:46:42+08:00" />
<meta property="article:modified_time" content="2020-02-19T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d" />


    

    
    
    
    <title>
        
        iOS 中的锁🔒
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">iOS 中的锁🔒</div>

        
<div class="section" id="content">
    Wed Feb 19, 2020 &#183; 440 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/thread/">
                thread
            </a>
        </span>
        
        
    </div>
    <hr/>
    <h1 id="lock">Lock</h1>
<p>之前总结了<a href="https://github.com/FelixScat/Pub/blob/master/posts/atomic.md">atomic的安全性问题</a>，那么在诸如此类的并发使用资源的情况下该如何保证线程安全呢，这篇主要想总结下各种锁的使用</p>
<p>还使用之前电影院卖票的栗子来说明</p>
<p>Theater.h</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Theater</span> : <span style="color:#a6e22e">NSObject</span>

<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) NSInteger ticketNum;

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>main.m</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#75715e">// insert code here...
</span><span style="color:#75715e"></span>        
        Theater <span style="color:#f92672">*</span>theater <span style="color:#f92672">=</span> [[Theater alloc] init];
        <span style="color:#75715e">// 定义总票数为2000
</span><span style="color:#75715e"></span>        theater.ticketNum <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>;
        <span style="color:#75715e">// 并发队列用于卖票
</span><span style="color:#75715e"></span>        dispatch_queue_t concurrentQueue <span style="color:#f92672">=</span> dispatch_queue_create(<span style="color:#e6db74">&#34;com.test.example0&#34;</span>, DISPATCH_QUEUE_CONCURRENT);

        <span style="color:#75715e">// 将总票数分为4部分分别添加到并发队列执行卖票操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
          dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {
            	theater.ticketNum<span style="color:#f92672">--</span>;
              NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
            }
          });
        }

        <span style="color:#75715e">// 使用栅栏函数等待前面任务完成，最后打印卖完票后的总票数
</span><span style="color:#75715e"></span>        dispatch_barrier_sync(concurrentQueue, <span style="color:#f92672">^</span>{
          NSLog(<span style="color:#e6db74">@&#34;%ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
        });
        
        
        NSLog(<span style="color:#e6db74">@&#34;Enter (q) to quit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">char</span> input[<span style="color:#ae81ff">100</span>];
        <span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74">&#34;%[^</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">]%*c&#34;</span>, input)) {
            NSString <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> [NSString stringWithCString:input encoding:NSUTF8StringEncoding];
            <span style="color:#66d9ef">if</span> ([str isEqualToString:<span style="color:#e6db74">@&#34;q&#34;</span>]) {
                exit(<span style="color:#ae81ff">0</span>);
            }
        }
        
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>接下来就用以下不同类型的锁来保障电影院卖票的线程安全吧</p>
<h2 id="osspinlock">OSSpinLock</h2>
<p>OSSpinLock是一种自旋锁，已经被废弃了，因为有可能导致优先级反转的问题</p>
<blockquote>
<p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p>
<p>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。</p>
</blockquote>
<p>但是既然说到了锁我们还是简单了解下它的用法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> OSSpinLock lock <span style="color:#f92672">=</span> OS_SPINLOCK_INIT;
OSSpinLockLock(<span style="color:#f92672">&amp;</span>lock);
theater.ticketNum<span style="color:#f92672">--</span>;
OSSpinLockUnlock(<span style="color:#f92672">&amp;</span>lock);
</code></pre></div><h2 id="os_unfair_lock">os_unfair_lock</h2>
<p>是 OSSpinLock 的替代方案，不过 os_unfair_lock 不是自旋锁而是互斥锁</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> os_unfair_lock lock <span style="color:#f92672">=</span> OS_UNFAIR_LOCK_INIT;
os_unfair_lock_lock(<span style="color:#f92672">&amp;</span>lock);
theater.ticketNum<span style="color:#f92672">--</span>;
os_unfair_lock_unlock(<span style="color:#f92672">&amp;</span>lock);
</code></pre></div><h2 id="pthread_mutex">pthread_mutex</h2>
<p>pthread_mutex本质为互斥锁</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 初始化锁
</span><span style="color:#75715e"></span>pthread_mutexattr_t attr;
pthread_mutexattr_init(<span style="color:#f92672">&amp;</span>attr);
pthread_mutexattr_settype(<span style="color:#f92672">&amp;</span>attr, PTHREAD_MUTEX_DEFAULT);

<span style="color:#66d9ef">static</span> pthread_mutex_t mutex;
pthread_mutex_init(<span style="color:#f92672">&amp;</span>mutex, <span style="color:#f92672">&amp;</span>attr);

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
  dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {

      pthread_mutex_lock(<span style="color:#f92672">&amp;</span>mutex);
      theater.ticketNum<span style="color:#f92672">--</span>;
      pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>mutex);

      NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
    }
  });
}


<span style="color:#75715e">// 使用栅栏函数等待前面任务完成，最后打印卖完票后的总票数
</span><span style="color:#75715e"></span>dispatch_barrier_sync(concurrentQueue, <span style="color:#f92672">^</span>{
  NSLog(<span style="color:#e6db74">@&#34;%ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
});

<span style="color:#75715e">// 销毁
</span><span style="color:#75715e"></span>pthread_mutexattr_destroy(<span style="color:#f92672">&amp;</span>attr);
pthread_mutex_destroy(<span style="color:#f92672">&amp;</span>mutex);
</code></pre></div><h2 id="nslock">NSLock</h2>
<p>NSLock为pthread_mutex的封装</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSLock <span style="color:#f92672">*</span>lock <span style="color:#f92672">=</span> [[NSLock alloc] init];
        
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
  dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {
      [lock lock];
      theater.ticketNum<span style="color:#f92672">--</span>;
      [lock unlock];

      NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
    }
  });
}
</code></pre></div><h2 id="nsrecursivelock">NSRecursiveLock</h2>
<p>pthread_mutex 的封装，能够实现同一线程对资源多次加锁</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSRecursiveLock <span style="color:#f92672">*</span>lock <span style="color:#f92672">=</span> [[NSRecursiveLock alloc] init];

<span style="color:#75715e">// 将总票数分为4部分分别添加到并发队列执行卖票操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
  dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {
      [lock lock];
      theater.ticketNum<span style="color:#f92672">--</span>;
      [lock unlock];

      NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
    }
  });
}
</code></pre></div><h2 id="nsconditionlock">NSConditionLock</h2>
<p>NSConditionLock 也是对pthread_mutex的封装，优点是可以在多处增加加锁的条件，自定义的程度比较高</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSConditionLock <span style="color:#f92672">*</span>lock <span style="color:#f92672">=</span> [[NSConditionLock alloc] initWithCondition:<span style="color:#ae81ff">0</span>];

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
  dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {
      [lock lockWhenCondition:<span style="color:#ae81ff">0</span>];
      theater.ticketNum<span style="color:#f92672">--</span>;
      [lock unlockWithCondition:<span style="color:#ae81ff">0</span>];

      NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
    }
  });
}
</code></pre></div><h2 id="synchronized">@synchronized</h2>
<p>本质也是对pthread_mutex的封装</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
  dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {

      <span style="color:#66d9ef">@synchronized</span> (theater) {
        theater.ticketNum<span style="color:#f92672">--</span>;
      }

      NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
    }
  });
}
</code></pre></div><h2 id="信号量">信号量</h2>
<p>dispatch_semaphore_t 是GCD提供的同步机制，其中</p>
<p>dispatch_semaphore_create 用来初始化信号量，</p>
<p>dispatch_semaphore_wait 函数会将信号量的值减1，并且当信号量大小小于0时会一直等待</p>
<p>dispatch_semaphore_signal 函数会将信号量的值加1</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">dispatch_semaphore_t semaphore_t <span style="color:#f92672">=</span> dispatch_semaphore_create(<span style="color:#ae81ff">1</span>);
        
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
  dispatch_async(concurrentQueue, <span style="color:#f92672">^</span>{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">500</span>; i<span style="color:#f92672">++</span>) {

      dispatch_semaphore_wait(semaphore_t, DISPATCH_TIME_FOREVER);
      theater.ticketNum<span style="color:#f92672">--</span>;
      dispatch_semaphore_signal(semaphore_t);

      NSLog(<span style="color:#e6db74">@&#34;sold one ticket ,left: %ld&#34;</span>, (<span style="color:#66d9ef">long</span>)theater.ticketNum);
    }
  });
}
</code></pre></div>
</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/memoryManage">memoryManage</a>
        
            &#183; 
            <a href="http://example.org/portfolio">portfolio</a>
        
            &#183; 
            <a href="http://example.org/about">who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog.</div>
    </div>
</body>

</html>