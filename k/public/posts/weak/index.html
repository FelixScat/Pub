<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Cb7d &#39;s blog">
<title>
ObjC 的 weak 修饰 - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="ObjC 的 weak 修饰"/>
<meta name="twitter:description" content="Weak 我们在代码中可以找到很多地方使用了weak来修饰成员变量，比如
@property (nonatomic, weak, nullable) id &lt;UITableViewDelegate&gt; delegate; Weak的作用  weak 用于修饰的对象被赋值不会引起retain，销毁也不会release，weak指针指向的对象一旦被释放，weak的指针将会被置为nil
 大部分情况下我们的代码中都会存在着各种持有其他对象的情况，而被持有的对象可能由于某些需求需要访问原对象，那么就会导致互相持有对方，在ARC下，俩个对象互相持有将导致内存一直无法释放，因为每个对象在自动释放池中的retainCount都大于0。由于weak的特性，这个时候就轮到他出场了
什么时候应该用Weak  通常在使用代理模式的时候应该使用weak来避免循环引用 在使用block时需要引用block外部的变量的时候可以用weak来断链 需要对象释放是自动置为nil，防止野指针错误   这里有个小技巧，只要你的类要完成的功能是需要借用的，就用weak
 Weak实现的机制 我们现在只知道在weak对象销毁后会置为nil，接下来我们从源码角度看看weak到底是如何实现的
NSObject *one = [[NSObject alloc] init]; __weak typeof(one) oneWeak = one; 在代码中单步断点，我们可以看到进入了这个方法
ObjCSample`objc_initWeak: -&gt; 0x100000e7e &lt;&#43;0&gt;: jmpq *0x1cc(%rip) ; (void *)0x0000000100000ed0 看到这个方法就好办了，我们掏出源码瞅瞅这个方法做了啥
NSObject.mm
/** * Initialize a fresh weak pointer to some object location. * It would be used for code like: * * (The nil case) * __weak id weakPtr; * (The non-nil case) * NSObject *o = ."/>

<meta property="og:title" content="ObjC 的 weak 修饰" />
<meta property="og:description" content="Weak 我们在代码中可以找到很多地方使用了weak来修饰成员变量，比如
@property (nonatomic, weak, nullable) id &lt;UITableViewDelegate&gt; delegate; Weak的作用  weak 用于修饰的对象被赋值不会引起retain，销毁也不会release，weak指针指向的对象一旦被释放，weak的指针将会被置为nil
 大部分情况下我们的代码中都会存在着各种持有其他对象的情况，而被持有的对象可能由于某些需求需要访问原对象，那么就会导致互相持有对方，在ARC下，俩个对象互相持有将导致内存一直无法释放，因为每个对象在自动释放池中的retainCount都大于0。由于weak的特性，这个时候就轮到他出场了
什么时候应该用Weak  通常在使用代理模式的时候应该使用weak来避免循环引用 在使用block时需要引用block外部的变量的时候可以用weak来断链 需要对象释放是自动置为nil，防止野指针错误   这里有个小技巧，只要你的类要完成的功能是需要借用的，就用weak
 Weak实现的机制 我们现在只知道在weak对象销毁后会置为nil，接下来我们从源码角度看看weak到底是如何实现的
NSObject *one = [[NSObject alloc] init]; __weak typeof(one) oneWeak = one; 在代码中单步断点，我们可以看到进入了这个方法
ObjCSample`objc_initWeak: -&gt; 0x100000e7e &lt;&#43;0&gt;: jmpq *0x1cc(%rip) ; (void *)0x0000000100000ed0 看到这个方法就好办了，我们掏出源码瞅瞅这个方法做了啥
NSObject.mm
/** * Initialize a fresh weak pointer to some object location. * It would be used for code like: * * (The nil case) * __weak id weakPtr; * (The non-nil case) * NSObject *o = ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/weak/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2019-07-19T10:46:42+08:00" />
<meta property="article:modified_time" content="2019-07-19T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d &#39;s blog" />


    

    
    
    
    <title>
        
        ObjC 的 weak 修饰
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">ObjC 的 weak 修饰</div>

        
<div class="section" id="content">
    Fri Jul 19, 2019 &#183; 1314 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
    </div>
    <hr/>
    <h1 id="weak">Weak</h1>
<p>我们在代码中可以找到很多地方使用了weak来修饰成员变量，比如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">weak</span>, nullable) <span style="color:#66d9ef">id</span> <span style="color:#f92672">&lt;</span>UITableViewDelegate<span style="color:#f92672">&gt;</span> delegate;
</code></pre></div><h2 id="weak的作用">Weak的作用</h2>
<blockquote>
<p>weak 用于修饰的对象被赋值不会引起retain，销毁也不会release，weak指针指向的对象一旦被释放，weak的指针将会被置为nil</p>
</blockquote>
<p>大部分情况下我们的代码中都会存在着各种持有其他对象的情况，而被持有的对象可能由于某些需求需要访问原对象，那么就会导致互相持有对方，在ARC下，俩个对象互相持有将导致内存一直无法释放，因为每个对象在自动释放池中的retainCount都大于0。由于weak的特性，这个时候就轮到他出场了</p>
<h2 id="什么时候应该用weak">什么时候应该用Weak</h2>
<ul>
<li>通常在使用代理模式的时候应该使用weak来避免循环引用</li>
<li>在使用block时需要引用block外部的变量的时候可以用weak来断链</li>
<li>需要对象释放是自动置为nil，防止野指针错误</li>
</ul>
<blockquote>
<p>这里有个小技巧，只要你的类要完成的功能是需要<strong>借用</strong>的，就用weak</p>
</blockquote>
<h2 id="weak实现的机制">Weak实现的机制</h2>
<p>我们现在只知道在weak对象销毁后会置为nil，接下来我们从源码角度看看weak到底是如何实现的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSObject <span style="color:#f92672">*</span>one <span style="color:#f92672">=</span> [[NSObject alloc] init];

<span style="color:#66d9ef">__weak</span> <span style="color:#a6e22e">typeof</span>(one) oneWeak <span style="color:#f92672">=</span> one;
</code></pre></div><p>在代码中单步断点，我们可以看到进入了这个方法</p>
<pre><code class="language-assembly" data-lang="assembly">ObjCSample`objc_initWeak:
-&gt;  0x100000e7e &lt;+0&gt;: jmpq   *0x1cc(%rip)              ; (void *)0x0000000100000ed0
</code></pre><p>看到这个方法就好办了，我们掏出源码瞅瞅这个方法做了啥</p>
<p>NSObject.mm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/** 
</span><span style="color:#75715e"> * Initialize a fresh weak pointer to some object location. 
</span><span style="color:#75715e"> * It would be used for code like: 
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * (The nil case) 
</span><span style="color:#75715e"> * __weak id weakPtr;
</span><span style="color:#75715e"> * (The non-nil case) 
</span><span style="color:#75715e"> * NSObject *o = ...;
</span><span style="color:#75715e"> * __weak id weakPtr = o;
</span><span style="color:#75715e"> * 
</span><span style="color:#75715e"> * This function IS NOT thread-safe with respect to concurrent 
</span><span style="color:#75715e"> * modifications to the weak variable. (Concurrent weak clear is safe.)
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param location Address of __weak ptr. 
</span><span style="color:#75715e"> * @param newObj Object ptr. 
</span><span style="color:#75715e"> */</span>
id
<span style="color:#a6e22e">objc_initWeak</span>(id <span style="color:#f92672">*</span>location, id newObj)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newObj) {
        <span style="color:#f92672">*</span>location <span style="color:#f92672">=</span> nil;
        <span style="color:#66d9ef">return</span> nil;
    }

    <span style="color:#66d9ef">return</span> storeWeak<span style="color:#f92672">&lt;</span>DontHaveOld, DoHaveNew, DoCrashIfDeallocating<span style="color:#f92672">&gt;</span>
        (location, (objc_object<span style="color:#f92672">*</span>)newObj);
}
</code></pre></div><p>可以看到这里是个外层方法，仅判断了对象是不是nil，下面会进入</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 这里用于更新 weak 变量
</span><span style="color:#75715e">// 如果 HaveOld 为 true，说明变量已经有存在于weak表中的值了，需要清理
</span><span style="color:#75715e">// 如果 HaveNew 为 true，说明变量需要被赋值
</span><span style="color:#75715e">// 如果 CrashIfDeallocating 为 true，说明 newObj 已经释放或者 newObj 不支持弱引用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">CrashIfDeallocating</span> {
    DontCrashIfDeallocating <span style="color:#f92672">=</span> false, DoCrashIfDeallocating <span style="color:#f92672">=</span> true
};
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>HaveOld haveOld, HaveNew haveNew,
          CrashIfDeallocating crashIfDeallocating<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">static</span> id 
storeWeak(id <span style="color:#f92672">*</span>location, objc_object <span style="color:#f92672">*</span>newObj)
{
    assert(haveOld  <span style="color:#f92672">||</span>  haveNew);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>haveNew) assert(newObj <span style="color:#f92672">==</span> nil);

    Class previouslyInitializedClass <span style="color:#f92672">=</span> nil;
    id oldObj;
    <span style="color:#75715e">// 声明新值和旧值所在的SideTable
</span><span style="color:#75715e"></span>    SideTable <span style="color:#f92672">*</span>oldTable;
    SideTable <span style="color:#f92672">*</span>newTable;

    <span style="color:#75715e">// Acquire locks for old and new values.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Order by lock address to prevent lock ordering problems. 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Retry if the old value changes underneath us.
</span><span style="color:#75715e"></span> retry:
    <span style="color:#75715e">// 获取旧对象和旧对象的SideTable
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (haveOld) {
        oldObj <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>location;
        oldTable <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>SideTables()[oldObj];
    } <span style="color:#66d9ef">else</span> {
        oldTable <span style="color:#f92672">=</span> nil;
    }
		<span style="color:#75715e">// 获取新对象所在的SideTable
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (haveNew) {
        newTable <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>SideTables()[newObj];
    } <span style="color:#66d9ef">else</span> {
        newTable <span style="color:#f92672">=</span> nil;
    }
		<span style="color:#75715e">// 对两张表加锁，防止多线程资源抢夺
</span><span style="color:#75715e"></span>    SideTable<span style="color:#f92672">::</span>lockTwo<span style="color:#f92672">&lt;</span>haveOld, haveNew<span style="color:#f92672">&gt;</span>(oldTable, newTable);
		
    <span style="color:#75715e">// 若旧值和从指针取出的值不一样则认为已经被其他线程修改，进行重试
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (haveOld  <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#f92672">*</span>location <span style="color:#f92672">!=</span> oldObj) {
        SideTable<span style="color:#f92672">::</span>unlockTwo<span style="color:#f92672">&lt;</span>haveOld, haveNew<span style="color:#f92672">&gt;</span>(oldTable, newTable);
        <span style="color:#66d9ef">goto</span> retry;
    }
            
    <span style="color:#66d9ef">if</span> (haveNew  <span style="color:#f92672">&amp;&amp;</span>  newObj) {
      	<span style="color:#75715e">// 获取isa指针
</span><span style="color:#75715e"></span>        Class cls <span style="color:#f92672">=</span> newObj<span style="color:#f92672">-&gt;</span>getIsa();
      	<span style="color:#75715e">// 如果isa非空并且isa没有被初始化，初始化isa并重试
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cls <span style="color:#f92672">!=</span> previouslyInitializedClass  <span style="color:#f92672">&amp;&amp;</span>  
            <span style="color:#f92672">!</span>((objc_class <span style="color:#f92672">*</span>)cls)<span style="color:#f92672">-&gt;</span>isInitialized()) 
        {
            SideTable<span style="color:#f92672">::</span>unlockTwo<span style="color:#f92672">&lt;</span>haveOld, haveNew<span style="color:#f92672">&gt;</span>(oldTable, newTable);
            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));

            previouslyInitializedClass <span style="color:#f92672">=</span> cls;

            <span style="color:#66d9ef">goto</span> retry;
        }
    }

    <span style="color:#75715e">// 清理旧值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (haveOld) {
        weak_unregister_no_lock(<span style="color:#f92672">&amp;</span>oldTable<span style="color:#f92672">-&gt;</span>weak_table, oldObj, location);
    }

    <span style="color:#75715e">// 新值赋值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (haveNew) {
        newObj <span style="color:#f92672">=</span> (objc_object <span style="color:#f92672">*</span>)
            weak_register_no_lock(<span style="color:#f92672">&amp;</span>newTable<span style="color:#f92672">-&gt;</span>weak_table, (id)newObj, location, 
                                  crashIfDeallocating);
        <span style="color:#75715e">// weak_register_no_lock returns nil if weak store should be rejected
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 在引用计数表中标记
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (newObj  <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#f92672">!</span>newObj<span style="color:#f92672">-&gt;</span>isTaggedPointer()) {
            newObj<span style="color:#f92672">-&gt;</span>setWeaklyReferenced_nolock();
        }

        <span style="color:#75715e">// 改变location指向新的对象
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>location <span style="color:#f92672">=</span> (id)newObj;
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// No new value. The storage is not changed.
</span><span style="color:#75715e"></span>    }
    
    SideTable<span style="color:#f92672">::</span>unlockTwo<span style="color:#f92672">&lt;</span>haveOld, haveNew<span style="color:#f92672">&gt;</span>(oldTable, newTable);

    <span style="color:#66d9ef">return</span> (id)newObj;
}
</code></pre></div><p>可以看到取对象的代码是 <code>&amp;SideTables()[oldObj]</code> 那么这个东西里面是什么呢</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> StripedMap<span style="color:#f92672">&lt;</span>SideTable<span style="color:#f92672">&gt;&amp;</span> SideTables() {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>StripedMap<span style="color:#f92672">&lt;</span>SideTable<span style="color:#f92672">&gt;*&gt;</span>(SideTableBuf);
}
</code></pre></div><p>其中：</p>
<ul>
<li>reinterpret_cast 为 c++ 的类型转换方法，简单来说就是使用 <code>StripedMap&lt;SideTable&gt;*</code> 的方式来读写 SideTableBuf 的值</li>
<li><code>StripedMap&lt;T&gt;</code> 是一个模版类，根据传递的实际参数决定其中array成员存储的元素类型，能通过对象的地址计算Hash值，通过该值找到对应的value</li>
</ul>
<p>下面我们接着看 SideTable</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SideTable</span> {
    spinlock_t slock;
    RefcountMap refcnts;
    weak_table_t weak_table;

    SideTable() {
        memset(<span style="color:#f92672">&amp;</span>weak_table, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(weak_table));
    }

    <span style="color:#f92672">~</span>SideTable() {
        _objc_fatal(<span style="color:#e6db74">&#34;Do not delete SideTable.&#34;</span>);
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() { slock.lock(); }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() { slock.unlock(); }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">forceReset</span>() { slock.forceReset(); }

    <span style="color:#75715e">// Address-ordered lock discipline for a pair of side tables.
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>HaveOld, HaveNew<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> lockTwo(SideTable <span style="color:#f92672">*</span>lock1, SideTable <span style="color:#f92672">*</span>lock2);
    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>HaveOld, HaveNew<span style="color:#f92672">&gt;</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> unlockTwo(SideTable <span style="color:#f92672">*</span>lock1, SideTable <span style="color:#f92672">*</span>lock2);
};
</code></pre></div><p>SideTable 我觉得翻译成 <strong>小边桌</strong> 比较合适，就像角落里的桌子，没多少人但是也必须有。我们看它的数据结构</p>
<ul>
<li>spinlock_t slock 用来保障多线程安全（注：别被名字骗了，早就不是自旋锁了）</li>
<li>RefcountMap refcnts 管理对象的引用计数</li>
<li>weak_table_t weak_table 真正的weak表</li>
</ul>
<p>下面看weak表是个什么结构</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * The global weak references table. Stores object ids as keys,
</span><span style="color:#75715e"> * and weak_entry_t structs as their values.
</span><span style="color:#75715e"> */</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * 全局弱引用的表，将对象的id作为key
</span><span style="color:#75715e"> * weak_entry_t 作为value
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">weak_table_t</span> {
  	<span style="color:#75715e">// 存储所有指向指定对象的 weak 指针，也就是最终包装weak对象的地方
</span><span style="color:#75715e"></span>    weak_entry_t <span style="color:#f92672">*</span>weak_entries;
  	<span style="color:#75715e">// 容量
</span><span style="color:#75715e"></span>    size_t    num_entries;
  	<span style="color:#75715e">// 掩码
</span><span style="color:#75715e"></span>    uintptr_t mask;
  	<span style="color:#75715e">// Hash key 最大偏移量
</span><span style="color:#75715e"></span>    uintptr_t max_hash_displacement;
};
</code></pre></div><p>再来看下 weak_entry_t</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define REFERRERS_OUT_OF_LINE 2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">weak_entry_t</span> {
  	<span style="color:#75715e">// 内存中的weak对象，DisguisedPtr是为了防止被误报为内存泄漏
</span><span style="color:#75715e"></span>    DisguisedPtr<span style="color:#f92672">&lt;</span>objc_object<span style="color:#f92672">&gt;</span> referent;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">struct</span> {
          	<span style="color:#75715e">// 所有指向weak对象的变量
</span><span style="color:#75715e"></span>            weak_referrer_t <span style="color:#f92672">*</span>referrers;
            uintptr_t        out_of_line_ness : <span style="color:#ae81ff">2</span>;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        <span style="color:#66d9ef">struct</span> {
            <span style="color:#75715e">// out_of_line_ness field is low bits of inline_referrers[1]
</span><span style="color:#75715e"></span>            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">out_of_line</span>() {
        <span style="color:#66d9ef">return</span> (out_of_line_ness <span style="color:#f92672">==</span> REFERRERS_OUT_OF_LINE);
    }

    weak_entry_t<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> weak_entry_t<span style="color:#f92672">&amp;</span> other) {
        memcpy(<span style="color:#66d9ef">this</span>, <span style="color:#f92672">&amp;</span>other, <span style="color:#66d9ef">sizeof</span>(other));
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    weak_entry_t(objc_object <span style="color:#f92672">*</span>newReferent, objc_object <span style="color:#f92672">**</span>newReferrer)
        <span style="color:#f92672">:</span> referent(newReferent)
    {
        inline_referrers[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> newReferrer;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> WEAK_INLINE_COUNT; i<span style="color:#f92672">++</span>) {
            inline_referrers[i] <span style="color:#f92672">=</span> nil;
        }
    }
};
</code></pre></div><h3 id="小总结一下">小总结一下</h3>
<p>综上可以我们可以得出一下结论</p>
<ul>
<li>weak_table_t 是一个全局的弱引用表，负责存储全局的弱引用数据</li>
<li>weak_table_t 中的 weak_entries 负责维护指向每一个对象的所有弱引用 Hash 表</li>
</ul>
<p>下面看看注册weak表的方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/** 
</span><span style="color:#75715e"> * Registers a new (object, weak pointer) pair. Creates a new weak
</span><span style="color:#75715e"> * object entry if it does not exist.
</span><span style="color:#75715e"> * 
</span><span style="color:#75715e"> * @param weak_table The global weak table.
</span><span style="color:#75715e"> * @param referent The object pointed to by the weak reference.
</span><span style="color:#75715e"> * @param referrer The weak pointer address.
</span><span style="color:#75715e"> */</span>
id 
<span style="color:#a6e22e">weak_register_no_lock</span>(weak_table_t <span style="color:#f92672">*</span>weak_table, id referent_id, 
                      id <span style="color:#f92672">*</span>referrer_id, <span style="color:#66d9ef">bool</span> crashIfDeallocating)
{
  	<span style="color:#75715e">// 对象的值，也就是weak表中的key
</span><span style="color:#75715e"></span>    objc_object <span style="color:#f92672">*</span>referent <span style="color:#f92672">=</span> (objc_object <span style="color:#f92672">*</span>)referent_id;
  	<span style="color:#75715e">// 对象的地址（指针）
</span><span style="color:#75715e"></span>    objc_object <span style="color:#f92672">**</span>referrer <span style="color:#f92672">=</span> (objc_object <span style="color:#f92672">**</span>)referrer_id;
		<span style="color:#75715e">// 如果对象为空或者该对象使用了 TaggedPointer 技术则直接返回原对象（注：关于 TaggedPointer 本文暂且不表，以后会专门写一篇）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>referent  <span style="color:#f92672">||</span>  referent<span style="color:#f92672">-&gt;</span>isTaggedPointer()) <span style="color:#66d9ef">return</span> referent_id;

    <span style="color:#75715e">// 对象是否有效
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> deallocating;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>referent<span style="color:#f92672">-&gt;</span>ISA()<span style="color:#f92672">-&gt;</span>hasCustomRR()) {
        deallocating <span style="color:#f92672">=</span> referent<span style="color:#f92672">-&gt;</span>rootIsDeallocating();
    }
    <span style="color:#66d9ef">else</span> {
        BOOL (<span style="color:#f92672">*</span>allowsWeakReference)(objc_object <span style="color:#f92672">*</span>, SEL) <span style="color:#f92672">=</span> 
            (BOOL(<span style="color:#f92672">*</span>)(objc_object <span style="color:#f92672">*</span>, SEL))
            object_getMethodImplementation((id)referent, 
                                           SEL_allowsWeakReference);
        <span style="color:#66d9ef">if</span> ((IMP)allowsWeakReference <span style="color:#f92672">==</span> _objc_msgForward) {
            <span style="color:#66d9ef">return</span> nil;
        }
        deallocating <span style="color:#f92672">=</span>
            <span style="color:#f92672">!</span> (<span style="color:#f92672">*</span>allowsWeakReference)(referent, SEL_allowsWeakReference);
    }
		<span style="color:#75715e">// 对象 dealloc
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (deallocating) {
        <span style="color:#66d9ef">if</span> (crashIfDeallocating) {
            _objc_fatal(<span style="color:#e6db74">&#34;Cannot form weak reference to instance (%p) of &#34;</span>
                        <span style="color:#e6db74">&#34;class %s. It is possible that this object was &#34;</span>
                        <span style="color:#e6db74">&#34;over-released, or is in the process of deallocation.&#34;</span>,
                        (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)referent, object_getClassName((id)referent));
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> nil;
        }
    }

    <span style="color:#75715e">// 判断对象是否有关联的弱引用表
</span><span style="color:#75715e"></span>    weak_entry_t <span style="color:#f92672">*</span>entry;
    <span style="color:#66d9ef">if</span> ((entry <span style="color:#f92672">=</span> weak_entry_for_referent(weak_table, referent))) {
      	<span style="color:#75715e">// 添加关联
</span><span style="color:#75715e"></span>        append_referrer(entry, referrer);
    } 
    <span style="color:#66d9ef">else</span> {
      	<span style="color:#75715e">// 创建weak实体
</span><span style="color:#75715e"></span>        weak_entry_t new_entry(referent, referrer);
      	<span style="color:#75715e">// 表满扩容
</span><span style="color:#75715e"></span>        weak_grow_maybe(weak_table);
      	<span style="color:#75715e">// 插值
</span><span style="color:#75715e"></span>        weak_entry_insert(weak_table, <span style="color:#f92672">&amp;</span>new_entry);
    }

    <span style="color:#75715e">// Do not set *referrer. objc_storeWeak() requires that the 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// value not change.
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> referent_id;
}
</code></pre></div><p>接下来我们看看旧对象的解除操作</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/** 
</span><span style="color:#75715e"> * Unregister an already-registered weak reference.
</span><span style="color:#75715e"> * This is used when referrer&#39;s storage is about to go away, but referent
</span><span style="color:#75715e"> * isn&#39;t dead yet. (Otherwise, zeroing referrer later would be a
</span><span style="color:#75715e"> * bad memory access.)
</span><span style="color:#75715e"> * Does nothing if referent/referrer is not a currently active weak reference.
</span><span style="color:#75715e"> * Does not zero referrer.
</span><span style="color:#75715e"> * 
</span><span style="color:#75715e"> * FIXME currently requires old referent value to be passed in (lame)
</span><span style="color:#75715e"> * FIXME unregistration should be automatic if referrer is collected
</span><span style="color:#75715e"> * 
</span><span style="color:#75715e"> * @param weak_table The global weak table.
</span><span style="color:#75715e"> * @param referent The object.
</span><span style="color:#75715e"> * @param referrer The weak reference.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">weak_unregister_no_lock</span>(weak_table_t <span style="color:#f92672">*</span>weak_table, id referent_id, 
                        id <span style="color:#f92672">*</span>referrer_id)
{
  	<span style="color:#75715e">// 旧对象的值，也就是weak表中的key
</span><span style="color:#75715e"></span>    objc_object <span style="color:#f92672">*</span>referent <span style="color:#f92672">=</span> (objc_object <span style="color:#f92672">*</span>)referent_id;
  	<span style="color:#75715e">// 旧对象的地址（指针）
</span><span style="color:#75715e"></span>    objc_object <span style="color:#f92672">**</span>referrer <span style="color:#f92672">=</span> (objc_object <span style="color:#f92672">**</span>)referrer_id;

    weak_entry_t <span style="color:#f92672">*</span>entry;
		<span style="color:#75715e">// 对象为nil直接返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>referent) <span style="color:#66d9ef">return</span>;
		<span style="color:#75715e">// 根据weak表和旧对象的值查找weak_entry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((entry <span style="color:#f92672">=</span> weak_entry_for_referent(weak_table, referent))) {
      	<span style="color:#75715e">// 删除引用关联
</span><span style="color:#75715e"></span>        remove_referrer(entry, referrer);
        <span style="color:#66d9ef">bool</span> empty <span style="color:#f92672">=</span> true;
        <span style="color:#66d9ef">if</span> (entry<span style="color:#f92672">-&gt;</span>out_of_line()  <span style="color:#f92672">&amp;&amp;</span>  entry<span style="color:#f92672">-&gt;</span>num_refs <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
            empty <span style="color:#f92672">=</span> false;
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> WEAK_INLINE_COUNT; i<span style="color:#f92672">++</span>) {
                <span style="color:#66d9ef">if</span> (entry<span style="color:#f92672">-&gt;</span>inline_referrers[i]) {
                    empty <span style="color:#f92672">=</span> false; 
                    <span style="color:#66d9ef">break</span>;
                }
            }
        }
				<span style="color:#75715e">// 如果该对象的弱引用列表为空则从table中移除
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (empty) {
            weak_entry_remove(weak_table, entry);
        }
    }

    <span style="color:#75715e">// Do not set *referrer = nil. objc_storeWeak() requires that the 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// value not change.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>我们在使用weak修饰对象的时候显然是不会调用这个方法的，那么啥情况下会执行呢</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">testMethod</span> {
    <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
    ...
    ...
}
</code></pre></div><p>我们在这里声明了 weakSelf 这个局部变量，在方法作用结束之后局部变量将被释放，这个时候就会调用解除操作方法把 weakSelf 从当前对象的弱引用列表中移除。</p>
<h3 id="在对象释放的时候weak表又做了啥">在对象释放的时候weak表又做了啥</h3>
<p>我们可以一层一层从NSObject的dealloc开始追溯</p>
<p>NSObject.mm</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#f92672">-</span> (<span style="color:#66d9ef">void</span>)dealloc {
    _objc_rootDealloc(self);
}
</code></pre></div><p>objc-object.h</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
objc_object<span style="color:#f92672">::</span>rootDealloc()
{
    <span style="color:#66d9ef">if</span> (isTaggedPointer()) <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">// fixme necessary?
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> (fastpath(isa.nonpointer  <span style="color:#f92672">&amp;&amp;</span>  
                 <span style="color:#f92672">!</span>isa.weakly_referenced  <span style="color:#f92672">&amp;&amp;</span>  
                 <span style="color:#f92672">!</span>isa.has_assoc  <span style="color:#f92672">&amp;&amp;</span>  
                 <span style="color:#f92672">!</span>isa.has_cxx_dtor  <span style="color:#f92672">&amp;&amp;</span>  
                 <span style="color:#f92672">!</span>isa.has_sidetable_rc))
    {
        assert(<span style="color:#f92672">!</span>sidetable_present());
        free(<span style="color:#66d9ef">this</span>);
    } 
    <span style="color:#66d9ef">else</span> {
        object_dispose((id)<span style="color:#66d9ef">this</span>);
    }
}
</code></pre></div><p>最终到达这个方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/** 
</span><span style="color:#75715e"> * Called by dealloc; nils out all weak pointers that point to the 
</span><span style="color:#75715e"> * provided object so that they can no longer be used.
</span><span style="color:#75715e"> * 
</span><span style="color:#75715e"> * @param weak_table 
</span><span style="color:#75715e"> * @param referent The object being deallocated. 
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> 
<span style="color:#a6e22e">weak_clear_no_lock</span>(weak_table_t <span style="color:#f92672">*</span>weak_table, id referent_id) 
{
  	<span style="color:#75715e">// 正在dealloc的对象
</span><span style="color:#75715e"></span>    objc_object <span style="color:#f92672">*</span>referent <span style="color:#f92672">=</span> (objc_object <span style="color:#f92672">*</span>)referent_id;
		<span style="color:#75715e">// 根据weak表和该对象的值找到weak对应的entry
</span><span style="color:#75715e"></span>    weak_entry_t <span style="color:#f92672">*</span>entry <span style="color:#f92672">=</span> weak_entry_for_referent(weak_table, referent);
    <span style="color:#66d9ef">if</span> (entry <span style="color:#f92672">==</span> nil) {
        <span style="color:#75715e">/// XXX shouldn&#39;t happen, but does with mismatched CF/objc
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//printf(&#34;XXX no entry for clear deallocating %p\n&#34;, referent);
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e">// zero out references
</span><span style="color:#75715e"></span>    weak_referrer_t <span style="color:#f92672">*</span>referrers;
    size_t count;
    
    <span style="color:#66d9ef">if</span> (entry<span style="color:#f92672">-&gt;</span>out_of_line()) {
        referrers <span style="color:#f92672">=</span> entry<span style="color:#f92672">-&gt;</span>referrers;
        count <span style="color:#f92672">=</span> TABLE_SIZE(entry);
    } 
    <span style="color:#66d9ef">else</span> {
        referrers <span style="color:#f92672">=</span> entry<span style="color:#f92672">-&gt;</span>inline_referrers;
        count <span style="color:#f92672">=</span> WEAK_INLINE_COUNT;
    }
    <span style="color:#75715e">// 删除引用关联
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; <span style="color:#f92672">++</span>i) {
        objc_object <span style="color:#f92672">**</span>referrer <span style="color:#f92672">=</span> referrers[i];
        <span style="color:#66d9ef">if</span> (referrer) {
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>referrer <span style="color:#f92672">==</span> referent) {
                <span style="color:#f92672">*</span>referrer <span style="color:#f92672">=</span> nil;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>referrer) {
                _objc_inform(<span style="color:#e6db74">&#34;__weak variable at %p holds %p instead of %p. &#34;</span>
                             <span style="color:#e6db74">&#34;This is probably incorrect use of &#34;</span>
                             <span style="color:#e6db74">&#34;objc_storeWeak() and objc_loadWeak(). &#34;</span>
                             <span style="color:#e6db74">&#34;Break on objc_weak_error to debug.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, 
                             referrer, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">*</span>referrer, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)referent);
                objc_weak_error();
            }
        }
    }
    <span style="color:#75715e">// 删除对象关联的weak_entry
</span><span style="color:#75715e"></span>    weak_entry_remove(weak_table, entry);
}
</code></pre></div><h2 id="总结">总结</h2>
<p>到这里整个weak的实现思路都完成了，我们总结下初始化和释放的过程吧</p>
<h3 id="初始化过程">初始化过程</h3>
<ol>
<li>获取 SideTable</li>
<li>获取 weak_table_t（key为赋值对象地址的hash）</li>
<li>生成 weak_entry_t （主要作用包装被weak修饰的指针变量地址）</li>
</ol>
<h3 id="释放过程">释放过程</h3>
<ol>
<li>获取 SideTable</li>
<li>获取 weak_table_t</li>
<li>获取 weak_entry_t</li>
<li>销毁所有 weak_entry_t 指向对象的指针</li>
<li>销毁 weak_entry_t</li>
</ol>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">Posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/tags/objc/">Arithmetic</a>
        
            &#183; 
            <a href="http://example.org/about">Who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog. <a href="mailto:cb7d23@gmail.com">cb7d23@gmail.com</a></div>
    </div>
</body>

</html>