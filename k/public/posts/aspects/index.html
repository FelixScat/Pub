<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="A new Hugo site.">
<title>
Aspects 面向切面编程 - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="Aspects 面向切面编程"/>
<meta name="twitter:description" content="Aspects 本文示例工程
什么是AOP？
面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。
在开发过程中我们总会遇到某种需求，需要对我们业务内部的所有状态进行统一管理，比如对点击事件，用户进入的页面等进行埋点处理，对于这种需求我们一般会想到利用 Runtime 的消息转发功能实现这种需求，对这块不熟悉的同学可以看这篇，下面我们来看下 Aspects 是如何设计的
使用方式 先看下接口里面的方法
@interface NSObject (Aspects) /// Adds a block of code before/instead/after the current `selector` for a specific class. /// /// @param block Aspects replicates the type signature of the method being hooked. /// The first parameter will be `id&lt;AspectInfo&gt;`, followed by all parameters of the method. /// These parameters are optional and will be filled to match the block signature."/>

<meta property="og:title" content="Aspects 面向切面编程" />
<meta property="og:description" content="Aspects 本文示例工程
什么是AOP？
面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。
在开发过程中我们总会遇到某种需求，需要对我们业务内部的所有状态进行统一管理，比如对点击事件，用户进入的页面等进行埋点处理，对于这种需求我们一般会想到利用 Runtime 的消息转发功能实现这种需求，对这块不熟悉的同学可以看这篇，下面我们来看下 Aspects 是如何设计的
使用方式 先看下接口里面的方法
@interface NSObject (Aspects) /// Adds a block of code before/instead/after the current `selector` for a specific class. /// /// @param block Aspects replicates the type signature of the method being hooked. /// The first parameter will be `id&lt;AspectInfo&gt;`, followed by all parameters of the method. /// These parameters are optional and will be filled to match the block signature." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/aspects/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2020-02-19T10:46:42+08:00" />
<meta property="article:modified_time" content="2020-02-19T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d" />


    

    
    
    
    <title>
        
        Aspects 面向切面编程
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">Aspects 面向切面编程</div>

        
<div class="section" id="content">
    Wed Feb 19, 2020 &#183; 1191 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
        
        
    </div>
    <hr/>
    <h1 id="aspects">Aspects</h1>
<p><a href="https://github.com/FelixScat/demo_Aspects">本文示例工程</a></p>
<p>什么是AOP？</p>
<p><strong>面向切面的程序设计</strong>（Aspect-oriented programming，AOP，又译作<strong>面向方面的程序设计</strong>、<strong>剖面导向程序设计</strong>）是<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中的一种<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">程序设计思想</a>，旨在将<strong>横切关注点</strong>与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的<strong>通知</strong>（Advice）机制，能够对被声明为“<strong>切点</strong>（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。</p>
<p>在开发过程中我们总会遇到某种需求，需要对我们业务内部的所有状态进行统一管理，比如对点击事件，用户进入的页面等进行埋点处理，对于这种需求我们一般会想到利用 <strong>Runtime</strong> 的消息转发功能实现这种需求，对这块不熟悉的同学可以<a href="https://k.felixplus.top/runtime/">看这篇</a>，下面我们来看下 <strong>Aspects</strong> 是如何设计的</p>
<h2 id="使用方式">使用方式</h2>
<p>先看下接口里面的方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">NSObject</span> (Aspects)

<span style="color:#75715e">/// Adds a block of code before/instead/after the current `selector` for a specific class.
</span><span style="color:#75715e">///
</span><span style="color:#75715e">/// @param block Aspects replicates the type signature of the method being hooked.
</span><span style="color:#75715e">/// The first parameter will be `id&lt;AspectInfo&gt;`, followed by all parameters of the method.
</span><span style="color:#75715e">/// These parameters are optional and will be filled to match the block signature.
</span><span style="color:#75715e">/// You can even use an empty block, or one that simple gets `id&lt;AspectInfo&gt;`.
</span><span style="color:#75715e">///
</span><span style="color:#75715e">/// @note Hooking static methods is not supported.
</span><span style="color:#75715e">/// @return A token which allows to later deregister the aspect.
</span><span style="color:#75715e"></span>+ (<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectToken<span style="color:#f92672">&gt;</span>)<span style="color:#a6e22e">aspect_hookSelector:</span>(<span style="color:#66d9ef">SEL</span>)selector
                      <span style="color:#a6e22e">withOptions:</span>(AspectOptions)options
                       <span style="color:#a6e22e">usingBlock:</span>(<span style="color:#66d9ef">id</span>)block
                            <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">**</span>)error;

<span style="color:#75715e">/// Adds a block of code before/instead/after the current `selector` for a specific instance.
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectToken<span style="color:#f92672">&gt;</span>)<span style="color:#a6e22e">aspect_hookSelector:</span>(<span style="color:#66d9ef">SEL</span>)selector
                      <span style="color:#a6e22e">withOptions:</span>(AspectOptions)options
                       <span style="color:#a6e22e">usingBlock:</span>(<span style="color:#66d9ef">id</span>)block
                            <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">**</span>)error;

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>注意方法中的注释中特意提到了目前不支持静态方法的hook，方便的一点是 Aspect 需要传入的block是id类型，我们定义block的时候可以声明传递所有需要的参数，也可以什么都不传。</p>
<p>基本的使用方式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">
<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">NSObject</span> (Track)

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">load</span> {
    
    [UIViewController aspect_hookSelector:<span style="color:#66d9ef">@selector</span>(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:<span style="color:#f92672">^</span>(<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectInfo<span style="color:#f92672">&gt;</span> aspectInfo, <span style="color:#66d9ef">BOOL</span> animated) {
        NSLog(<span style="color:#e6db74">@&#34;View Controller %@ will appear animated: %tu&#34;</span>, aspectInfo.instance, animated);
    } error:NULL];
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>上面是返回类型为 <strong>void</strong> 的方法，需要返回参数的hook方式稍微复杂一点</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#import &#34;FKViewController.h&#34;
</span><span style="color:#75715e">#import &lt;Aspects/Aspects.h&gt;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">FKViewController</span> ()

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">FKViewController</span>

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">viewDidLoad</span>
{
    [super viewDidLoad];
	<span style="color:#75715e">// Do any additional setup after loading the view, typically from a nib.
</span><span style="color:#75715e"></span>    
    [self aspect_hookSelector:<span style="color:#66d9ef">@selector</span>(giveMeFive) withOptions:AspectPositionInstead usingBlock:<span style="color:#f92672">^</span>(<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectInfo<span style="color:#f92672">&gt;</span> info) {
        <span style="color:#75715e">// Call original implementation.
</span><span style="color:#75715e"></span>        NSNumber <span style="color:#f92672">*</span>number;
        NSInvocation <span style="color:#f92672">*</span>invocation <span style="color:#f92672">=</span> info.originalInvocation;
        [invocation invoke];
        [invocation getReturnValue:<span style="color:#f92672">&amp;</span>number];
        
        <span style="color:#66d9ef">if</span> (number) {
            number <span style="color:#f92672">=</span> <span style="color:#ae81ff">@(</span><span style="color:#ae81ff">10</span><span style="color:#ae81ff">)</span>;
            [invocation setReturnValue:<span style="color:#f92672">&amp;</span>number];
        }
        
    } error:NULL];
}

- (NSNumber <span style="color:#f92672">*</span>)<span style="color:#a6e22e">giveMeFive</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">@(</span><span style="color:#ae81ff">5</span><span style="color:#ae81ff">)</span>;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">touchesBegan:</span>(NSSet<span style="color:#f92672">&lt;</span>UITouch <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">*</span>)touches <span style="color:#a6e22e">withEvent:</span>(UIEvent <span style="color:#f92672">*</span>)event {
    
    NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>, [self giveMeFive]);
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><h2 id="深入源码">深入源码</h2>
<h3 id="aspects-定义的结构">Aspects 定义的结构</h3>
<h4 id="hook选项">Hook选项</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">NS_OPTIONS</span>(NSUInteger, AspectOptions) {
    AspectPositionAfter   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,            <span style="color:#75715e">/// 在原方法后调用(默认)
</span><span style="color:#75715e"></span>    AspectPositionInstead <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,            <span style="color:#75715e">/// 直接替换
</span><span style="color:#75715e"></span>    AspectPositionBefore  <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,            <span style="color:#75715e">/// 在原方法之前
</span><span style="color:#75715e"></span>    
    AspectOptionAutomaticRemoval <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span> <span style="color:#75715e">/// 第一次执行后取消
</span><span style="color:#75715e"></span>};
</code></pre></div><p>这里并没有使用枚举，而是使用了 NS_OPTIONS，方便组合选项</p>
<h4 id="提供销毁hook的实例">提供销毁Hook的实例</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">AspectToken</span> <span style="color:#f92672">&lt;</span>NSObject<span style="color:#f92672">&gt;</span>

<span style="color:#75715e">/// Deregisters an aspect.
</span><span style="color:#75715e">/// @return YES if deregistration is successful, otherwise NO.
</span><span style="color:#75715e"></span><span style="color:#f92672">-</span> (<span style="color:#66d9ef">BOOL</span>)remove;

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>用协议的形式向外部暴露一个可销毁的选项，我们看下如何销毁执行的hook</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">FKViewController</span> ()

<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectToken<span style="color:#f92672">&gt;</span> token;

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">FKViewController</span>

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">viewDidLoad</span>
{
    [super viewDidLoad];
	<span style="color:#75715e">// Do any additional setup after loading the view, typically from a nib.
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
    _token <span style="color:#f92672">=</span> [self aspect_hookSelector:<span style="color:#66d9ef">@selector</span>(giveMeFive) withOptions:AspectPositionInstead usingBlock:<span style="color:#f92672">^</span>(<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectInfo<span style="color:#f92672">&gt;</span> info) {
        <span style="color:#75715e">// Call original implementation.
</span><span style="color:#75715e"></span>        NSNumber <span style="color:#f92672">*</span>number;
        NSInvocation <span style="color:#f92672">*</span>invocation <span style="color:#f92672">=</span> info.originalInvocation;
        [invocation invoke];
        [invocation getReturnValue:<span style="color:#f92672">&amp;</span>number];
        
        <span style="color:#66d9ef">if</span> (number) {
            number <span style="color:#f92672">=</span> <span style="color:#ae81ff">@(</span><span style="color:#ae81ff">10</span><span style="color:#ae81ff">)</span>;
            [invocation setReturnValue:<span style="color:#f92672">&amp;</span>number];
            [weakSelf.token remove];
        }
        
    } error:NULL];
}

- (NSNumber <span style="color:#f92672">*</span>)<span style="color:#a6e22e">giveMeFive</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">@(</span><span style="color:#ae81ff">5</span><span style="color:#ae81ff">)</span>;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">touchesBegan:</span>(NSSet<span style="color:#f92672">&lt;</span>UITouch <span style="color:#f92672">*&gt;</span> <span style="color:#f92672">*</span>)touches <span style="color:#a6e22e">withEvent:</span>(UIEvent <span style="color:#f92672">*</span>)event {
    
    NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>, [self giveMeFive]);
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>运行后多次点击屏幕，只有第一次会输出10了</p>
<h4 id="定义错误类型">定义错误类型</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">NS_ENUM</span>(NSUInteger, AspectErrorCode) {
    AspectErrorSelectorBlacklisted,                   <span style="color:#75715e">/// 无法hook的方法，release, retain等
</span><span style="color:#75715e"></span>    AspectErrorDoesNotRespondToSelector,              <span style="color:#75715e">/// 找不到方法
</span><span style="color:#75715e"></span>    AspectErrorSelectorDeallocPosition,               <span style="color:#75715e">/// hook dealloc方法只能选择在执行该方法前
</span><span style="color:#75715e"></span>    AspectErrorSelectorAlreadyHookedInClassHierarchy, <span style="color:#75715e">/// 在子类中hook的方法已经被hook过
</span><span style="color:#75715e"></span>    AspectErrorFailedToAllocateClassPair,             <span style="color:#75715e">/// objc_allocateClassPair 失败
</span><span style="color:#75715e"></span>    AspectErrorMissingBlockSignature,                 <span style="color:#75715e">/// hook回调的block没有签名
</span><span style="color:#75715e"></span>    AspectErrorIncompatibleBlockSignature,            <span style="color:#75715e">/// 签名不匹配
</span><span style="color:#75715e"></span>
    AspectErrorRemoveObjectAlreadyDeallocated <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>   <span style="color:#75715e">/// hook已经被移除
</span><span style="color:#75715e"></span>};
</code></pre></div><h4 id="定义返回block">定义返回block</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _AspectBlock {
	__unused <span style="color:#66d9ef">Class</span> isa;
	AspectBlockFlags flags;
	__unused <span style="color:#66d9ef">int</span> reserved;
	<span style="color:#66d9ef">void</span> (__unused <span style="color:#f92672">*</span>invoke)(<span style="color:#66d9ef">struct</span> _AspectBlock <span style="color:#f92672">*</span>block, ...);
	<span style="color:#66d9ef">struct</span> {
		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> reserved;
		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> size;
		<span style="color:#75715e">// requires AspectBlockFlagsHasCopyDisposeHelpers
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">copy</span>)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src);
		<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>);
		<span style="color:#75715e">// requires AspectBlockFlagsHasSignature
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>signature;
		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>layout;
	} <span style="color:#f92672">*</span>descriptor;
	<span style="color:#75715e">// imported variables
</span><span style="color:#75715e"></span>} <span style="color:#f92672">*</span>AspectBlockRef;
</code></pre></div><h4 id="定义返回的aspect信息">定义返回的Aspect信息</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">AspectInfo</span> <span style="color:#f92672">&lt;</span>NSObject<span style="color:#f92672">&gt;</span>

<span style="color:#75715e">/// The instance that is currently hooked.
</span><span style="color:#75715e"></span><span style="color:#f92672">-</span> (<span style="color:#66d9ef">id</span>)instance;

<span style="color:#75715e">/// The original invocation of the hooked method.
</span><span style="color:#75715e"></span>- (NSInvocation <span style="color:#f92672">*</span>)<span style="color:#a6e22e">originalInvocation</span>;

<span style="color:#75715e">/// All method arguments, boxed. This is lazily evaluated.
</span><span style="color:#75715e"></span>- (NSArray <span style="color:#f92672">*</span>)<span style="color:#a6e22e">arguments</span>;

<span style="color:#66d9ef">@end</span>
</code></pre></div><h4 id="定义用来追踪单个-aspect-的-aspectidentifier">定义用来追踪单个 aspect 的 <strong>AspectIdentifier</strong></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// Tracks a single aspect.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">AspectIdentifier</span> : <span style="color:#a6e22e">NSObject</span>
+ (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">identifierWithSelector:</span>(<span style="color:#66d9ef">SEL</span>)selector <span style="color:#a6e22e">object:</span>(<span style="color:#66d9ef">id</span>)object <span style="color:#a6e22e">options:</span>(AspectOptions)options <span style="color:#a6e22e">block:</span>(<span style="color:#66d9ef">id</span>)block <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">**</span>)error;
- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">invokeWithInfo:</span>(<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectInfo<span style="color:#f92672">&gt;</span>)info;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) <span style="color:#66d9ef">SEL</span> selector;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) <span style="color:#66d9ef">id</span> block;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) NSMethodSignature <span style="color:#f92672">*</span>blockSignature;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">weak</span>) <span style="color:#66d9ef">id</span> object;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) AspectOptions options;
<span style="color:#66d9ef">@end</span>
</code></pre></div><h4 id="负责追踪类的类">负责追踪类的类</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">AspectTracker</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">initWithTrackedClass:</span>(<span style="color:#66d9ef">Class</span>)trackedClass <span style="color:#a6e22e">parent:</span>(AspectTracker <span style="color:#f92672">*</span>)parent;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) <span style="color:#66d9ef">Class</span> trackedClass;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) NSMutableSet <span style="color:#f92672">*</span>selectorNames;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">weak</span>) AspectTracker <span style="color:#f92672">*</span>parentEntry;
<span style="color:#66d9ef">@end</span>
</code></pre></div><h4 id="aspect-的容器">aspect 的容器</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// Tracks all aspects for an object/class.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">AspectsContainer</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addAspect:</span>(AspectIdentifier <span style="color:#f92672">*</span>)aspect <span style="color:#a6e22e">withOptions:</span>(AspectOptions)injectPosition;
- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">removeAspect:</span>(<span style="color:#66d9ef">id</span>)aspect;
- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">hasAspects</span>;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">copy</span>) NSArray <span style="color:#f92672">*</span>beforeAspects;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">copy</span>) NSArray <span style="color:#f92672">*</span>insteadAspects;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">copy</span>) NSArray <span style="color:#f92672">*</span>afterAspects;
<span style="color:#66d9ef">@end</span>
</code></pre></div><hr>
<h3 id="具体实现">具体实现</h3>
<p>下面我们一步一步，了解一下 Aspects 完整的运作过程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">/// @return A token which allows to later deregister the aspect.
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>AspectToken<span style="color:#f92672">&gt;</span>)<span style="color:#a6e22e">aspect_hookSelector:</span>(<span style="color:#66d9ef">SEL</span>)selector
                      <span style="color:#a6e22e">withOptions:</span>(AspectOptions)options
                       <span style="color:#a6e22e">usingBlock:</span>(<span style="color:#66d9ef">id</span>)block
                            <span style="color:#a6e22e">error:</span>(NSError <span style="color:#f92672">**</span>)error {
    <span style="color:#66d9ef">return</span> aspect_add(self, selector, options, block, error);
}
</code></pre></div><p>类方法也是类似的原理，这里进入了 <strong>aspect_add</strong> 这个方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">id</span> <span style="color:#a6e22e">aspect_add</span>(<span style="color:#66d9ef">id</span> self, <span style="color:#66d9ef">SEL</span> selector, AspectOptions options, <span style="color:#66d9ef">id</span> block, NSError <span style="color:#f92672">**</span>error) {
  	<span style="color:#75715e">// 首先，先对参数内容进行检查，不要小瞧这一步，没个方法调用都对自己的参数进行检查才不容易出错
</span><span style="color:#75715e"></span>    NSCParameterAssert(self);
    NSCParameterAssert(selector);
    NSCParameterAssert(block);

    <span style="color:#66d9ef">__block</span> AspectIdentifier <span style="color:#f92672">*</span>identifier <span style="color:#f92672">=</span> nil;
  	<span style="color:#75715e">// 使用 OSSpinLock自旋锁 加锁 ，虽然 OSSpinLock 效率高一些
</span><span style="color:#75715e"></span>    aspect_performLocked(<span style="color:#f92672">^</span>{
        <span style="color:#66d9ef">if</span> (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
          	<span style="color:#75715e">// 获取aspect容器
</span><span style="color:#75715e"></span>            AspectsContainer <span style="color:#f92672">*</span>aspectContainer <span style="color:#f92672">=</span> aspect_getContainerForObject(self, selector);
          	<span style="color:#75715e">// 生成追踪的对象
</span><span style="color:#75715e"></span>            identifier <span style="color:#f92672">=</span> [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
            <span style="color:#66d9ef">if</span> (identifier) {
                [aspectContainer addAspect:identifier withOptions:options];

                <span style="color:#75715e">// Modify the class to allow message interception.
</span><span style="color:#75715e"></span>                aspect_prepareClassAndHookSelector(self, selector, error);
            }
        }
    });
    <span style="color:#66d9ef">return</span> identifier;
}
</code></pre></div><p>这里要注意，虽然自旋锁的效率高一些，但是也有潜在的风险，详情看 <a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的OSSpinLock</a></p>
<p>容器使用runtime动态绑定在对象上</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> AspectsContainer <span style="color:#f92672">*</span><span style="color:#a6e22e">aspect_getContainerForObject</span>(NSObject <span style="color:#f92672">*</span>self, <span style="color:#66d9ef">SEL</span> selector) {
    NSCParameterAssert(self);
    <span style="color:#66d9ef">SEL</span> aliasSelector <span style="color:#f92672">=</span> aspect_aliasForSelector(selector);
    AspectsContainer <span style="color:#f92672">*</span>aspectContainer <span style="color:#f92672">=</span> objc_getAssociatedObject(self, aliasSelector);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>aspectContainer) {
        aspectContainer <span style="color:#f92672">=</span> [AspectsContainer new];
        objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);
    }
    <span style="color:#66d9ef">return</span> aspectContainer;
}
</code></pre></div><p>下面开始真正的hook部分</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">aspect_prepareClassAndHookSelector</span>(NSObject <span style="color:#f92672">*</span>self, <span style="color:#66d9ef">SEL</span> selector, NSError <span style="color:#f92672">**</span>error) {
    NSCParameterAssert(selector);
  	<span style="color:#75715e">// 获取hook的class，所有的操作都在子类上进行，这样方便我们销毁hook时恢复isa，不造成影响
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">Class</span> klass <span style="color:#f92672">=</span> aspect_hookClass(self, error);
    Method targetMethod <span style="color:#f92672">=</span> class_getInstanceMethod(klass, selector);
    <span style="color:#66d9ef">IMP</span> targetMethodIMP <span style="color:#f92672">=</span> method_getImplementation(targetMethod);
  	<span style="color:#75715e">// 判断当前的imp是否为消息转发，如果不是消息转发就进行编码，添加方法并进行方法交换
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>aspect_isMsgForwardIMP(targetMethodIMP)) {
        <span style="color:#75715e">// Make a method alias for the existing method implementation, it not already copied.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>typeEncoding <span style="color:#f92672">=</span> method_getTypeEncoding(targetMethod);
        <span style="color:#66d9ef">SEL</span> aliasSelector <span style="color:#f92672">=</span> aspect_aliasForSelector(selector);
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[klass instancesRespondToSelector:aliasSelector]) {
            __unused <span style="color:#66d9ef">BOOL</span> addedAlias <span style="color:#f92672">=</span> class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
            NSCAssert(addedAlias, <span style="color:#e6db74">@&#34;Original implementation for %@ is already copied to %@ on %@&#34;</span>, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
        }

        <span style="color:#75715e">// We use forwardInvocation to hook in.
</span><span style="color:#75715e"></span>        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
        AspectLog(<span style="color:#e6db74">@&#34;Aspects: Installed hook for -[%@ %@].&#34;</span>, klass, NSStringFromSelector(selector));
    }
}
</code></pre></div><p>Hook 的部分告一段落，最后还有销毁 Hook 的收尾工作</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">BOOL</span> <span style="color:#a6e22e">aspect_remove</span>(AspectIdentifier <span style="color:#f92672">*</span>aspect, NSError <span style="color:#f92672">**</span>error) {
  	<span style="color:#75715e">// assert AspectIdentifier
</span><span style="color:#75715e"></span>    NSCAssert([aspect isKindOfClass:AspectIdentifier.<span style="color:#66d9ef">class</span>], <span style="color:#e6db74">@&#34;Must have correct type.&#34;</span>);

    <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">BOOL</span> success <span style="color:#f92672">=</span> NO;
    aspect_performLocked(<span style="color:#f92672">^</span>{
        <span style="color:#66d9ef">id</span> self <span style="color:#f92672">=</span> aspect.object; <span style="color:#75715e">// strongify
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (self) {
          	<span style="color:#75715e">// 取出容器，从容器中删除 aspect
</span><span style="color:#75715e"></span>            AspectsContainer <span style="color:#f92672">*</span>aspectContainer <span style="color:#f92672">=</span> aspect_getContainerForObject(self, aspect.selector);
            success <span style="color:#f92672">=</span> [aspectContainer removeAspect:aspect];
						
            aspect_cleanupHookedClassAndSelector(self, aspect.selector);
            <span style="color:#75715e">// destroy token
</span><span style="color:#75715e"></span>            aspect.object <span style="color:#f92672">=</span> nil;
            aspect.block <span style="color:#f92672">=</span> nil;
            aspect.selector <span style="color:#f92672">=</span> NULL;
        }<span style="color:#66d9ef">else</span> {
          	<span style="color:#75715e">// 当前对象已经释放
</span><span style="color:#75715e"></span>            NSString <span style="color:#f92672">*</span>errrorDesc <span style="color:#f92672">=</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;Unable to deregister hook. Object already deallocated: %@&#34;</span>, aspect];
            AspectError(AspectErrorRemoveObjectAlreadyDeallocated, errrorDesc);
        }
    });
    <span style="color:#66d9ef">return</span> success;
}
</code></pre></div><p>对使用runtime修改的东西进行还原</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="color:#75715e">// Will undo the runtime changes made.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">aspect_cleanupHookedClassAndSelector</span>(NSObject <span style="color:#f92672">*</span>self, <span style="color:#66d9ef">SEL</span> selector) {
    NSCParameterAssert(self);
    NSCParameterAssert(selector);
	
	<span style="color:#66d9ef">Class</span> klass <span style="color:#f92672">=</span> object_getClass(self);
    <span style="color:#66d9ef">BOOL</span> isMetaClass <span style="color:#f92672">=</span> class_isMetaClass(klass);
    <span style="color:#66d9ef">if</span> (isMetaClass) {
        klass <span style="color:#f92672">=</span> (<span style="color:#66d9ef">Class</span>)self;
    }
		
    <span style="color:#75715e">// 方法交换还原
</span><span style="color:#75715e"></span>    Method targetMethod <span style="color:#f92672">=</span> class_getInstanceMethod(klass, selector);
    <span style="color:#66d9ef">IMP</span> targetMethodIMP <span style="color:#f92672">=</span> method_getImplementation(targetMethod);
    <span style="color:#66d9ef">if</span> (aspect_isMsgForwardIMP(targetMethodIMP)) {
        <span style="color:#75715e">// Restore the original method implementation.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>typeEncoding <span style="color:#f92672">=</span> method_getTypeEncoding(targetMethod);
        <span style="color:#66d9ef">SEL</span> aliasSelector <span style="color:#f92672">=</span> aspect_aliasForSelector(selector);
        Method originalMethod <span style="color:#f92672">=</span> class_getInstanceMethod(klass, aliasSelector);
        <span style="color:#66d9ef">IMP</span> originalIMP <span style="color:#f92672">=</span> method_getImplementation(originalMethod);
        NSCAssert(originalMethod, <span style="color:#e6db74">@&#34;Original implementation for %@ not found %@ on %@&#34;</span>, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);

        class_replaceMethod(klass, selector, originalIMP, typeEncoding);
        AspectLog(<span style="color:#e6db74">@&#34;Aspects: Removed hook for -[%@ %@].&#34;</span>, klass, NSStringFromSelector(selector));
    }

    <span style="color:#75715e">// Deregister global tracked selector
</span><span style="color:#75715e"></span>    aspect_deregisterTrackedSelector(self, selector);

    <span style="color:#75715e">// 检查并清理container
</span><span style="color:#75715e"></span>    AspectsContainer <span style="color:#f92672">*</span>container <span style="color:#f92672">=</span> aspect_getContainerForObject(self, selector);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>container.hasAspects) {
        <span style="color:#75715e">// Destroy the container
</span><span style="color:#75715e"></span>        aspect_destroyContainerForObject(self, selector);

        <span style="color:#75715e">// Figure out how the class was modified to undo the changes.
</span><span style="color:#75715e"></span>        NSString <span style="color:#f92672">*</span>className <span style="color:#f92672">=</span> NSStringFromClass(klass);
        <span style="color:#66d9ef">if</span> ([className hasSuffix:AspectsSubclassSuffix]) {
            <span style="color:#66d9ef">Class</span> originalClass <span style="color:#f92672">=</span> NSClassFromString([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:<span style="color:#e6db74">@&#34;&#34;</span>]);
            NSCAssert(originalClass <span style="color:#f92672">!=</span> nil, <span style="color:#e6db74">@&#34;Original class must exist&#34;</span>);
            object_setClass(self, originalClass);
            AspectLog(<span style="color:#e6db74">@&#34;Aspects: %@ has been restored.&#34;</span>, NSStringFromClass(originalClass));

            <span style="color:#75715e">// We can only dispose the class pair if we can ensure that no instances exist using our subclass.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// Since we don&#39;t globally track this, we can&#39;t ensure this - but there&#39;s also not much overhead in keeping it around.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//objc_disposeClassPair(object.class);
</span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// Class is most likely swizzled in place. Undo that.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (isMetaClass) {
                aspect_undoSwizzleClassInPlace((<span style="color:#66d9ef">Class</span>)self);
            }
        }
    }
}
</code></pre></div><h2 id="结语">结语</h2>
<p>这一套下来比我们随手写的要复杂一些，但是 Aspects 也并不是完美的，同样存在一些坑点，比如当已经使用了其他方法交换的时候再次对该方法使用 Aspects ，所以使用的时候一定要注意，这里只是梳理和总结下代码的结构和逻辑，回头打算补充一张流程图😄</p>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/memoryManage">memoryManage</a>
        
            &#183; 
            <a href="http://example.org/portfolio">portfolio</a>
        
            &#183; 
            <a href="http://example.org/about">who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog.</div>
    </div>
</body>

</html>