<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Cb7d &#39;s blog">
<title>
SDWebimage 的高明之处 - Cb7d
</title>




<link rel="shortcut icon" href="https://min.felixplus.top/public/icon/man_icon_square.JPG?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ZYHZHANGYUNHAO931119%2F20200223%2F%2Fs3%2Faws4_request&amp;X-Amz-Date=20200223T024742Z&amp;X-Amz-Expires=432000&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=c5cfbe0ee2c297b46bcf68413178d4f0752d10171e51fe31713b02384b2617e3">








<link rel="stylesheet" href="http://example.org/css/main.min.81bbafc4df93b11c1c3e2449464373c384aa4903731b4fc7a77dfcdd979e184f.css" integrity="sha256-gbuvxN&#43;TsRwcPiRJRkNzw4SqSQNzG0/Hp3383ZeeGE8=" crossorigin="anonymous" media="screen">



 

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/tn.png"/>

<meta name="twitter:title" content="SDWebimage 的高明之处"/>
<meta name="twitter:description" content="SDWebImage 在上古时代，最粗暴的为imageView添加图片的姿势是这样的
NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&#34;https://github.com/FelixScat/Pub/blob/master/image/retainCircle.png?raw=true&#34;]]; [self.imgV setImage:[UIImage imageWithData:data]]; 而目前大部分iOS应用中都使用了网络图片缓存框架，使用最多的莫过于 SDWebImage 了，这篇主要从源码角度分析下，因为源码比较多，下文例子中可能会进行一些删减
调用接口 使用 SD 发起图片请求仅仅需要一行代码
[self.imgV sd_setImageWithURL:[NSURL URLWithString:@&#34;https://cn.bing.com/sa/simg/hpc26.png&#34;]]; 我们可以追踪进文件 UIImageView&#43;WebCache 里面
- (void)sd_setImageWithURL:(nullable NSURL *)url { [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil]; } - (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder { [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil]; } - (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options { [self sd_setImageWithURL:url placeholderImage:placeholder options:options progress:nil completed:nil]; } ... 这里发现这些方法最终都会调用同一个方法，相当于便利方法，为不同的需求提供多种接口，下面最终的方法是这样的
- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock { [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) { if (completedBlock) { completedBlock(image, error, cacheType, imageURL); } }]; } 这里调用的sd_internalSetImageWithURL方法是 UIView的分类，作者应该是希望和UIButton复用一份代码，所以把核心逻辑作为了UIView的分类"/>

<meta property="og:title" content="SDWebimage 的高明之处" />
<meta property="og:description" content="SDWebImage 在上古时代，最粗暴的为imageView添加图片的姿势是这样的
NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&#34;https://github.com/FelixScat/Pub/blob/master/image/retainCircle.png?raw=true&#34;]]; [self.imgV setImage:[UIImage imageWithData:data]]; 而目前大部分iOS应用中都使用了网络图片缓存框架，使用最多的莫过于 SDWebImage 了，这篇主要从源码角度分析下，因为源码比较多，下文例子中可能会进行一些删减
调用接口 使用 SD 发起图片请求仅仅需要一行代码
[self.imgV sd_setImageWithURL:[NSURL URLWithString:@&#34;https://cn.bing.com/sa/simg/hpc26.png&#34;]]; 我们可以追踪进文件 UIImageView&#43;WebCache 里面
- (void)sd_setImageWithURL:(nullable NSURL *)url { [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil]; } - (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder { [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil]; } - (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options { [self sd_setImageWithURL:url placeholderImage:placeholder options:options progress:nil completed:nil]; } ... 这里发现这些方法最终都会调用同一个方法，相当于便利方法，为不同的需求提供多种接口，下面最终的方法是这样的
- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock { [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) { if (completedBlock) { completedBlock(image, error, cacheType, imageURL); } }]; } 这里调用的sd_internalSetImageWithURL方法是 UIView的分类，作者应该是希望和UIButton复用一份代码，所以把核心逻辑作为了UIView的分类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/sdwebimage/" />
<meta property="og:image" content="http://example.org/tn.png"/>
<meta property="article:published_time" content="2019-06-18T10:46:42+08:00" />
<meta property="article:modified_time" content="2019-06-18T10:46:42+08:00" /><meta property="og:site_name" content="Cb7d &#39;s blog" />


    

    
    
    
    <title>
        
        SDWebimage 的高明之处
        
    </title>
</head>

<body>
    <div class="wrap">
        <div class="section" id="title">SDWebimage 的高明之处</div>

        
<div class="section" id="content">
    Tue Jun 18, 2019 &#183; 1684 words
    <div class="tag-container">
        
        
        <span class="tag">
            <a href="http://example.org/tags/blog/">
                blog
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/ios/">
                iOS
            </a>
        </span>
        
        
        
        <span class="tag">
            <a href="http://example.org/tags/objc/">
                ObjC
            </a>
        </span>
        
        
        
        
    </div>
    <hr/>
    <h1 id="sdwebimage">SDWebImage</h1>
<p>在上古时代，最粗暴的为imageView添加图片的姿势是这样的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSData <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> [NSData dataWithContentsOfURL:[NSURL URLWithString:<span style="color:#e6db74">@&#34;https://github.com/FelixScat/Pub/blob/master/image/retainCircle.png?raw=true&#34;</span>]];
[self.imgV setImage:[UIImage imageWithData:data]];

</code></pre></div><p>而目前大部分iOS应用中都使用了网络图片缓存框架，使用最多的莫过于 <strong>SDWebImage</strong> 了，这篇主要从源码角度分析下，因为源码比较多，下文例子中可能会进行一些删减</p>
<h2 id="调用接口">调用接口</h2>
<p>使用 SD 发起图片请求仅仅需要一行代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">[self.imgV sd_setImageWithURL:[NSURL URLWithString:<span style="color:#e6db74">@&#34;https://cn.bing.com/sa/simg/hpc26.png&#34;</span>]];
</code></pre></div><p>我们可以追踪进文件 <strong>UIImageView+WebCache</strong> 里面</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_setImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url {
    [self sd_setImageWithURL:url placeholderImage:nil options:<span style="color:#ae81ff">0</span> progress:nil completed:nil];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_setImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url <span style="color:#a6e22e">placeholderImage:</span>(nullable UIImage <span style="color:#f92672">*</span>)placeholder {
    [self sd_setImageWithURL:url placeholderImage:placeholder options:<span style="color:#ae81ff">0</span> progress:nil completed:nil];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_setImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url <span style="color:#a6e22e">placeholderImage:</span>(nullable UIImage <span style="color:#f92672">*</span>)placeholder <span style="color:#a6e22e">options:</span>(SDWebImageOptions)options {
    [self sd_setImageWithURL:url placeholderImage:placeholder options:options progress:nil completed:nil];
}

...
</code></pre></div><p>这里发现这些方法最终都会调用同一个方法，相当于便利方法，为不同的需求提供多种接口，下面最终的方法是这样的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_setImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url
          <span style="color:#a6e22e">placeholderImage:</span>(nullable UIImage <span style="color:#f92672">*</span>)placeholder
                   <span style="color:#a6e22e">options:</span>(SDWebImageOptions)options
                   <span style="color:#a6e22e">context:</span>(nullable SDWebImageContext <span style="color:#f92672">*</span>)context
                  <span style="color:#a6e22e">progress:</span>(nullable SDImageLoaderProgressBlock)progressBlock
                 <span style="color:#a6e22e">completed:</span>(nullable SDExternalCompletionBlock)completedBlock {
    [self sd_internalSetImageWithURL:url
                    placeholderImage:placeholder
                             options:options
                             context:context
                       setImageBlock:nil
                            progress:progressBlock
                           completed:<span style="color:#f92672">^</span>(UIImage <span style="color:#f92672">*</span> _Nullable image, NSData <span style="color:#f92672">*</span> _Nullable data, NSError <span style="color:#f92672">*</span> _Nullable error, SDImageCacheType cacheType, <span style="color:#66d9ef">BOOL</span> finished, NSURL <span style="color:#f92672">*</span> _Nullable imageURL) {
                               <span style="color:#66d9ef">if</span> (completedBlock) {
                                   completedBlock(image, error, cacheType, imageURL);
                               }
                           }];
}
</code></pre></div><p>这里调用的<code>sd_internalSetImageWithURL</code>方法是 <code>UIView</code>的分类，作者应该是希望和<code>UIButton</code>复用一份代码，所以把核心逻辑作为了<code>UIView</code>的分类</p>
<p>查看<code>UIView+WebCache.h</code>这个文件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 通过runtime为对象添加图片URL属性，只读
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>, <span style="color:#66d9ef">readonly</span>, nullable) NSURL <span style="color:#f92672">*</span>sd_imageURL;
<span style="color:#75715e">// 动态添加图片进度属性
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>, null_resettable) NSProgress <span style="color:#f92672">*</span>sd_imageProgress;
<span style="color:#75715e">// 动态添加图片过渡动画
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>, nullable) SDWebImageTransition <span style="color:#f92672">*</span>sd_imageTransition;
<span style="color:#75715e">// 动态添等待菊花
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>, nullable) <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>SDWebImageIndicator<span style="color:#f92672">&gt;</span> sd_imageIndicator;

<span style="color:#75715e">// 设置图片的核心方法
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_internalSetImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url
                  <span style="color:#a6e22e">placeholderImage:</span>(nullable UIImage <span style="color:#f92672">*</span>)placeholder
                           <span style="color:#a6e22e">options:</span>(SDWebImageOptions)options
                           <span style="color:#a6e22e">context:</span>(nullable SDWebImageContext <span style="color:#f92672">*</span>)context
                     <span style="color:#a6e22e">setImageBlock:</span>(nullable SDSetImageBlock)setImageBlock
                          <span style="color:#a6e22e">progress:</span>(nullable SDImageLoaderProgressBlock)progressBlock
                         <span style="color:#a6e22e">completed:</span>(nullable SDInternalCompletionBlock)completedBlock;

<span style="color:#75715e">// 取消当前加载的图片
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_cancelCurrentImageLoad</span>;
</code></pre></div><p>可以看到，逻辑很清晰，加载图片，取消加载，下面我们查看设置图片的核心方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_internalSetImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url
                  <span style="color:#a6e22e">placeholderImage:</span>(nullable UIImage <span style="color:#f92672">*</span>)placeholder
                           <span style="color:#a6e22e">options:</span>(SDWebImageOptions)options
                           <span style="color:#a6e22e">context:</span>(nullable SDWebImageContext <span style="color:#f92672">*</span>)context
                     <span style="color:#a6e22e">setImageBlock:</span>(nullable SDSetImageBlock)setImageBlock
                          <span style="color:#a6e22e">progress:</span>(nullable SDImageLoaderProgressBlock)progressBlock
                         <span style="color:#a6e22e">completed:</span>(nullable SDInternalCompletionBlock)completedBlock {
		<span style="color:#75715e">// 使用 copy 防止传入可变对象,
</span><span style="color:#75715e"></span>    context <span style="color:#f92672">=</span> [context <span style="color:#66d9ef">copy</span>]; 
                           
		<span style="color:#75715e">// 获取验证操作的key（后面会用到很多次），如果没有的话就用 NSStringFromClass 的方法用类名生成key
</span><span style="color:#75715e"></span>    NSString <span style="color:#f92672">*</span>validOperationKey <span style="color:#f92672">=</span> context[SDWebImageContextSetImageOperationKey];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>validOperationKey) {
        validOperationKey <span style="color:#f92672">=</span> NSStringFromClass([self <span style="color:#66d9ef">class</span>]);
    }
    self.sd_latestOperationKey <span style="color:#f92672">=</span> validOperationKey;
   
    <span style="color:#75715e">// 从Operation的Map中取消加载图片的operation
</span><span style="color:#75715e"></span>    [self sd_cancelImageLoadOperationWithKey:validOperationKey];
		<span style="color:#75715e">// runtime setURL
</span><span style="color:#75715e"></span>    self.sd_imageURL <span style="color:#f92672">=</span> url;
    
		<span style="color:#75715e">// 如果设置了延时加载占位图则不立即占位图片
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(options <span style="color:#f92672">&amp;</span> SDWebImageDelayPlaceholder)) {
      	<span style="color:#75715e">// 有关主队列和主线程的安全问题，下面会具体说这块
</span><span style="color:#75715e"></span>        dispatch_main_async_safe(<span style="color:#f92672">^</span>{
            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url];
        });
    }
    
    <span style="color:#66d9ef">if</span> (url) {
        <span style="color:#75715e">// 重设进度
</span><span style="color:#75715e"></span>        NSProgress <span style="color:#f92672">*</span>imageProgress <span style="color:#f92672">=</span> objc_getAssociatedObject(self, <span style="color:#66d9ef">@selector</span>(sd_imageProgress));
        <span style="color:#66d9ef">if</span> (imageProgress) {
            imageProgress.totalUnitCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            imageProgress.completedUnitCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#75715e">// 获取 SDWebImageManager
</span><span style="color:#75715e"></span>        SDWebImageManager <span style="color:#f92672">*</span>manager <span style="color:#f92672">=</span> context[SDWebImageContextCustomManager];
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>manager) {
            manager <span style="color:#f92672">=</span> [SDWebImageManager sharedManager];
        }
        
      	<span style="color:#75715e">// 设置下载进度回调
</span><span style="color:#75715e"></span>        SDImageLoaderProgressBlock combinedProgressBlock <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(NSInteger receivedSize, NSInteger expectedSize, NSURL <span style="color:#f92672">*</span> _Nullable targetURL) {
            <span style="color:#66d9ef">if</span> (imageProgress) {
                imageProgress.totalUnitCount <span style="color:#f92672">=</span> expectedSize;
                imageProgress.completedUnitCount <span style="color:#f92672">=</span> receivedSize;
            }
            <span style="color:#66d9ef">if</span> (progressBlock) {
                progressBlock(receivedSize, expectedSize, targetURL);
            }
        };
        @weakify(self);
      	<span style="color:#75715e">// 正式开始下载
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">id</span> <span style="color:#f92672">&lt;</span>SDWebImageOperation<span style="color:#f92672">&gt;</span> operation <span style="color:#f92672">=</span> [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:<span style="color:#f92672">^</span>(UIImage <span style="color:#f92672">*</span>image, NSData <span style="color:#f92672">*</span>data, NSError <span style="color:#f92672">*</span>error, SDImageCacheType cacheType, <span style="color:#66d9ef">BOOL</span> finished, NSURL <span style="color:#f92672">*</span>imageURL) {
            @strongify(self);
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self) { <span style="color:#66d9ef">return</span>; }
            <span style="color:#75715e">// 如果还没有更新progress，直接标记为完成
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (imageProgress <span style="color:#f92672">&amp;&amp;</span> finished <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>error <span style="color:#f92672">&amp;&amp;</span> imageProgress.totalUnitCount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> imageProgress.completedUnitCount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                imageProgress.totalUnitCount <span style="color:#f92672">=</span> SDWebImageProgressUnitCountUnknown;
                imageProgress.completedUnitCount <span style="color:#f92672">=</span> SDWebImageProgressUnitCountUnknown;
            }
            
<span style="color:#75715e">#if SD_UIKIT || SD_MAC
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// check and stop image indicator
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (finished) {
                [self sd_stopImageIndicator];
            }
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>            
          	<span style="color:#75715e">// 根据传入的option获取配置项
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">BOOL</span> shouldCallCompletedBlock <span style="color:#f92672">=</span> finished <span style="color:#f92672">||</span> (options <span style="color:#f92672">&amp;</span> SDWebImageAvoidAutoSetImage);
            <span style="color:#66d9ef">BOOL</span> shouldNotSetImage <span style="color:#f92672">=</span> ((image <span style="color:#f92672">&amp;&amp;</span> (options <span style="color:#f92672">&amp;</span> SDWebImageAvoidAutoSetImage)) <span style="color:#f92672">||</span>
                                      (<span style="color:#f92672">!</span>image <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(options <span style="color:#f92672">&amp;</span> SDWebImageDelayPlaceholder)));
            SDWebImageNoParamsBlock callCompletedBlockClojure <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self) { <span style="color:#66d9ef">return</span>; }
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>shouldNotSetImage) {
                    [self sd_setNeedsLayout];
                }
                <span style="color:#66d9ef">if</span> (completedBlock <span style="color:#f92672">&amp;&amp;</span> shouldCallCompletedBlock) {
                    completedBlock(image, data, error, cacheType, finished, url);
                }
            };
            
						<span style="color:#75715e">// 在主线程主队列回调，让调用方安全使用
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (shouldNotSetImage) {
                dispatch_main_async_safe(callCompletedBlockClojure);
                <span style="color:#66d9ef">return</span>;
            }
            
            UIImage <span style="color:#f92672">*</span>targetImage <span style="color:#f92672">=</span> nil;
            NSData <span style="color:#f92672">*</span>targetData <span style="color:#f92672">=</span> nil;
            <span style="color:#66d9ef">if</span> (image) {
                <span style="color:#75715e">// case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set
</span><span style="color:#75715e"></span>                targetImage <span style="color:#f92672">=</span> image;
                targetData <span style="color:#f92672">=</span> data;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (options <span style="color:#f92672">&amp;</span> SDWebImageDelayPlaceholder) {
              	<span style="color:#75715e">// 如果传入了 SDWebImageAvoidAutoSetImage 就在这时设置 placeholder
</span><span style="color:#75715e"></span>                targetImage <span style="color:#f92672">=</span> placeholder;
                targetData <span style="color:#f92672">=</span> nil;
            }
            
<span style="color:#75715e">#if SD_UIKIT || SD_MAC
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// transition 设置时机
</span><span style="color:#75715e"></span>            SDWebImageTransition <span style="color:#f92672">*</span>transition <span style="color:#f92672">=</span> nil;
            <span style="color:#66d9ef">if</span> (finished <span style="color:#f92672">&amp;&amp;</span> (options <span style="color:#f92672">&amp;</span> SDWebImageForceTransition <span style="color:#f92672">||</span> cacheType <span style="color:#f92672">==</span> SDImageCacheTypeNone)) {
                transition <span style="color:#f92672">=</span> self.sd_imageTransition;
            }
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>          	<span style="color:#75715e">// 在拿到图片后最终设置图片
</span><span style="color:#75715e"></span>            dispatch_main_async_safe(<span style="color:#f92672">^</span>{
<span style="color:#75715e">#if SD_UIKIT || SD_MAC
</span><span style="color:#75715e"></span>                [self sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>                [self sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:cacheType imageURL:imageURL];
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>                callCompletedBlockClojure();
            });
        }];
        [self sd_setImageLoadOperation:operation forKey:validOperationKey];
    } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 如果没传URL直接报错
</span><span style="color:#75715e"></span><span style="color:#75715e">#if SD_UIKIT || SD_MAC
</span><span style="color:#75715e"></span>        [self sd_stopImageIndicator];
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>        dispatch_main_async_safe(<span style="color:#f92672">^</span>{
            <span style="color:#66d9ef">if</span> (completedBlock) {
                NSError <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:<span style="color:#ae81ff">@{</span>NSLocalizedDescriptionKey : <span style="color:#e6db74">@&#34;Image url is nil&#34;</span><span style="color:#ae81ff">}</span>];
                completedBlock(nil, nil, error, SDImageCacheTypeNone, YES, url);
            }
        });
    }
}
</code></pre></div><p>这里有几个很有意思的点</p>
<ul>
<li><code>sd_cancelImageLoadOperationWithKey</code> &amp; <code>sd_setImageLoadOperation</code></li>
<li><code>dispatch_main_async_safe</code></li>
<li><code>#if SD_UIKIT || SD_MAC</code></li>
</ul>
<h3 id="imageloadoperation">ImageLoadOperation</h3>
<p>这是贯穿整个SD的一种管理模式，框架会为View生成一个管理operation的Map</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// runtime 关联对象
</span><span style="color:#75715e"></span>- (SDOperationsDictionary <span style="color:#f92672">*</span>)<span style="color:#a6e22e">sd_operationDictionary</span> {
    <span style="color:#66d9ef">@synchronized</span>(self) {
        SDOperationsDictionary <span style="color:#f92672">*</span>operations <span style="color:#f92672">=</span> objc_getAssociatedObject(self, <span style="color:#f92672">&amp;</span>loadOperationKey);
        <span style="color:#66d9ef">if</span> (operations) {
            <span style="color:#66d9ef">return</span> operations;
        }
      	<span style="color:#75715e">// NSMapTable 是一个使用自由度比较高的Map，可以自定义内存使用策略
</span><span style="color:#75715e"></span>        operations <span style="color:#f92672">=</span> [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:<span style="color:#ae81ff">0</span>];
        objc_setAssociatedObject(self, <span style="color:#f92672">&amp;</span>loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        <span style="color:#66d9ef">return</span> operations;
    }
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">sd_setImageLoadOperation:</span>(nullable <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>SDWebImageOperation<span style="color:#f92672">&gt;</span>)operation <span style="color:#a6e22e">forKey:</span>(nullable NSString <span style="color:#f92672">*</span>)key {
    <span style="color:#66d9ef">if</span> (key) {
      	<span style="color:#75715e">// 添加操作的时候先调用撤销
</span><span style="color:#75715e"></span>        [self sd_cancelImageLoadOperationWithKey:key];
        <span style="color:#66d9ef">if</span> (operation) {
            SDOperationsDictionary <span style="color:#f92672">*</span>operationDictionary <span style="color:#f92672">=</span> [self sd_operationDictionary];
          	<span style="color:#75715e">// 线程安全
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">@synchronized</span> (self) {
                [operationDictionary setObject:operation forKey:key];
            }
        }
    }
}
</code></pre></div><h3 id="dispatch_main_async_safe">dispatch_main_async_safe</h3>
<p>我们查看 dispatch_main_async_safe 这个宏定义的源码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#ifndef dispatch_main_async_safe
</span><span style="color:#75715e">#define dispatch_main_async_safe(block)\
</span><span style="color:#75715e">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) {\
</span><span style="color:#75715e">        block();\
</span><span style="color:#75715e">    } else {\
</span><span style="color:#75715e">        dispatch_async(dispatch_get_main_queue(), block);\
</span><span style="color:#75715e">    }
</span><span style="color:#75715e">#endif
</span></code></pre></div><p>这个宏的用途顾名思义是为了保障在主线程安全执行代码，按照一般的理解，上面if的判断中使用 <code>[NSThread isMainThread]</code> 也是可以的啊，为什么一定要使用 <code>dispatch_queue_get_label</code> 来判断呢，这是因为有一些UI的操作不但要在主线程，也一定要在主队列上执行，这时就要将任务添加到主队列以提升框架的健壮性。</p>
<h3 id="if-sd_uikit--sd_mac">#if SD_UIKIT || SD_MAC</h3>
<p>我们可以看到好多地方都有类似的定义，我们可以看这些宏具体的定义</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#if TARGET_OS_OSX
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_MAC 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_MAC 0
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// iOS and tvOS are very similar, UIKit exists on both platforms
</span><span style="color:#75715e">// Note: watchOS also has UIKit, but it&#39;s very limited
</span><span style="color:#75715e"></span><span style="color:#75715e">#if TARGET_OS_IOS || TARGET_OS_TV
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_UIKIT 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_UIKIT 0
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#if TARGET_OS_IOS
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_IOS 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_IOS 0
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#if TARGET_OS_TV
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_TV 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_TV 0
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#if TARGET_OS_WATCH
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_WATCH 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define SD_WATCH 0
</span><span style="color:#75715e">#endif
</span></code></pre></div><p>作者是自定义了一些宏来区分 target，我们开发的时候也可以这样多用一些自己定义的宏，不要直接去使用系统提供的，这样在以后的维护中也会方便一些</p>
<h2 id="sdwebimagemanager">SDWebImageManager</h2>
<p>下面让我们回到刚才获取图片的方法</p>
<p>SDWebImageManager.m</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (SDWebImageCombinedOperation <span style="color:#f92672">*</span>)<span style="color:#a6e22e">loadImageWithURL:</span>(nullable NSURL <span style="color:#f92672">*</span>)url
                                          <span style="color:#a6e22e">options:</span>(SDWebImageOptions)options
                                          <span style="color:#a6e22e">context:</span>(nullable SDWebImageContext <span style="color:#f92672">*</span>)context
                                         <span style="color:#a6e22e">progress:</span>(nullable SDImageLoaderProgressBlock)progressBlock
                                        <span style="color:#a6e22e">completed:</span>(nonnull SDInternalCompletionBlock)completedBlock {
    <span style="color:#75715e">// Invoking this method without a completedBlock is pointless
</span><span style="color:#75715e"></span>    NSAssert(completedBlock <span style="color:#f92672">!=</span> nil, <span style="color:#e6db74">@&#34;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&#34;</span>);

		<span style="color:#75715e">// 防止调用方直接传了NSString类型进来
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([url isKindOfClass:NSString.<span style="color:#66d9ef">class</span>]) {
        url <span style="color:#f92672">=</span> [NSURL URLWithString:(NSString <span style="color:#f92672">*</span>)url];
    }

    <span style="color:#75715e">// 如果生成的 URL 是 NSNull 的话，直接设置url为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[url isKindOfClass:NSURL.<span style="color:#66d9ef">class</span>]) {
        url <span style="color:#f92672">=</span> nil;
    }
		<span style="color:#75715e">//操作的对象，看过AFN源码的同学可能会有种似曾相识的感觉
</span><span style="color:#75715e"></span>    SDWebImageCombinedOperation <span style="color:#f92672">*</span>operation <span style="color:#f92672">=</span> [SDWebImageCombinedOperation new];
    operation.manager <span style="color:#f92672">=</span> self;
		
		<span style="color:#75715e">// 确认是否已经加载并且失败过
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">BOOL</span> isFailedUrl <span style="color:#f92672">=</span> NO;
    <span style="color:#66d9ef">if</span> (url) {
      	<span style="color:#75715e">// 加锁，使用 GCD 信号量
</span><span style="color:#75715e"></span>        SD_LOCK(self.failedURLsLock);
        isFailedUrl <span style="color:#f92672">=</span> [self.failedURLs containsObject:url];
        SD_UNLOCK(self.failedURLsLock);
    }
		
		<span style="color:#75715e">// 这里如果url地址为空字符串 || （配置项为设定失败后重试 &amp;&amp; 已经失败过）就直接返回错误信息
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (url.absoluteString.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> (<span style="color:#f92672">!</span>(options <span style="color:#f92672">&amp;</span> SDWebImageRetryFailed) <span style="color:#f92672">&amp;&amp;</span> isFailedUrl)) {
        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:<span style="color:#ae81ff">@{</span>NSLocalizedDescriptionKey : <span style="color:#e6db74">@&#34;Image url is nil&#34;</span><span style="color:#ae81ff">}</span>] url:url];
        <span style="color:#66d9ef">return</span> operation;
    }
		
		<span style="color:#75715e">// 同样适用GCD信号量加锁，将操作对象加入 MutableSet
</span><span style="color:#75715e"></span>    SD_LOCK(self.runningOperationsLock);
    [self.runningOperations addObject:operation];
    SD_UNLOCK(self.runningOperationsLock);
    
		<span style="color:#75715e">// 这里最终会用所有的选项和上下文对象生成resylt
</span><span style="color:#75715e"></span>    SDWebImageOptionsResult <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> [self processedResultForURL:url options:options context:context];
    
		<span style="color:#75715e">// 从缓存加载，传入进度和完成的回调
</span><span style="color:#75715e"></span>    [self callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock];

    <span style="color:#66d9ef">return</span> operation;
}
</code></pre></div><p>上面就是调用的外部接口的大概雏形了，下面我们深入缓存，看看SD的缓存究竟做了啥</p>
<h2 id="sdwebimagecombinedoperation">SDWebImageCombinedOperation</h2>
<p>上面我们在 <code>loadImageWithURL</code> 中看到初始化了一个 <strong>SDWebImageCombinedOperation</strong> 对象</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">SDWebImageCombinedOperation</span> : <span style="color:#a6e22e">NSObject</span> <span style="color:#f92672">&lt;</span>SDWebImageOperation<span style="color:#f92672">&gt;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> Cancel the current operation, including cache and loader process
</span><span style="color:#75715e"> */</span>
<span style="color:#f92672">-</span> (<span style="color:#66d9ef">void</span>)cancel;

<span style="color:#75715e">/**
</span><span style="color:#75715e"> The cache operation from the image cache query
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">strong</span>, <span style="color:#66d9ef">nonatomic</span>, nullable, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>SDWebImageOperation<span style="color:#f92672">&gt;</span> cacheOperation;

<span style="color:#75715e">/**
</span><span style="color:#75715e"> The loader operation from the image loader (such as download operation)
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">strong</span>, <span style="color:#66d9ef">nonatomic</span>, nullable, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>SDWebImageOperation<span style="color:#f92672">&gt;</span> loaderOperation;

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>这里的两个成员变量，cacheOperation 和 loaderOperation 就是缓存的调用者了，</p>
<p>先来看 cacheOperation</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">callCacheProcessForOperation:</span>(nonnull SDWebImageCombinedOperation <span style="color:#f92672">*</span>)operation
                                 <span style="color:#a6e22e">url:</span>(nonnull NSURL <span style="color:#f92672">*</span>)url
                             <span style="color:#a6e22e">options:</span>(SDWebImageOptions)options
                             <span style="color:#a6e22e">context:</span>(nullable SDWebImageContext <span style="color:#f92672">*</span>)context
                            <span style="color:#a6e22e">progress:</span>(nullable SDImageLoaderProgressBlock)progressBlock
                           <span style="color:#a6e22e">completed:</span>(nullable SDInternalCompletionBlock)completedBlock {
    <span style="color:#75715e">// Check whether we should query cache
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">BOOL</span> shouldQueryCache <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>SD_OPTIONS_CONTAINS(options, SDWebImageFromLoaderOnly);
    <span style="color:#66d9ef">if</span> (shouldQueryCache) {
        <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>SDWebImageCacheKeyFilter<span style="color:#f92672">&gt;</span> cacheKeyFilter <span style="color:#f92672">=</span> context[SDWebImageContextCacheKeyFilter];
        NSString <span style="color:#f92672">*</span>key <span style="color:#f92672">=</span> [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter];
        @weakify(operation);
        operation.cacheOperation <span style="color:#f92672">=</span> [self.imageCache queryImageForKey:key options:options context:context completion:<span style="color:#f92672">^</span>(UIImage <span style="color:#f92672">*</span> _Nullable cachedImage, NSData <span style="color:#f92672">*</span> _Nullable cachedData, SDImageCacheType cacheType) {
            @strongify(operation);
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>operation <span style="color:#f92672">||</span> operation.isCancelled) {
                <span style="color:#75715e">// Image combined operation cancelled by user
</span><span style="color:#75715e"></span>                [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:nil] url:url];
                [self safelyRemoveOperationFromRunning:operation];
                <span style="color:#66d9ef">return</span>;
            }
            <span style="color:#75715e">// Continue download process
</span><span style="color:#75715e"></span>            [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];
        }];
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// Continue download process
</span><span style="color:#75715e"></span>        [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock];
    }
}
</code></pre></div><p>这里调用了 <code>queryImageForKey</code> 这个方法，并把返回值赋值给了 cacheOperation ，这里直接看重点的实现代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (nullable NSOperation <span style="color:#f92672">*</span>)<span style="color:#a6e22e">queryCacheOperationForKey:</span>(nullable NSString <span style="color:#f92672">*</span>)key <span style="color:#a6e22e">options:</span>(SDImageCacheOptions)options <span style="color:#a6e22e">context:</span>(nullable SDWebImageContext <span style="color:#f92672">*</span>)context <span style="color:#a6e22e">done:</span>(nullable SDImageCacheQueryCompletionBlock)doneBlock {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>key) {
        <span style="color:#66d9ef">if</span> (doneBlock) {
            doneBlock(nil, nil, SDImageCacheTypeNone);
        }
        <span style="color:#66d9ef">return</span> nil;
    }
    
    <span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>SDImageTransformer<span style="color:#f92672">&gt;</span> transformer <span style="color:#f92672">=</span> context[SDWebImageContextImageTransformer];
    <span style="color:#66d9ef">if</span> (transformer) {
        <span style="color:#75715e">// grab the transformed disk image if transformer provided
</span><span style="color:#75715e"></span>        NSString <span style="color:#f92672">*</span>transformerKey <span style="color:#f92672">=</span> [transformer transformerKey];
        key <span style="color:#f92672">=</span> SDTransformedKeyForKey(key, transformerKey);
    }
    
    <span style="color:#75715e">// 先从内存缓存中取
</span><span style="color:#75715e"></span>    UIImage <span style="color:#f92672">*</span>image <span style="color:#f92672">=</span> [self imageFromMemoryCacheForKey:key];
    
    <span style="color:#66d9ef">if</span> (image) {
        <span style="color:#66d9ef">if</span> (options <span style="color:#f92672">&amp;</span> SDImageCacheDecodeFirstFrameOnly) {
            <span style="color:#75715e">// Ensure static image
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">Class</span> animatedImageClass <span style="color:#f92672">=</span> image.<span style="color:#66d9ef">class</span>;
            <span style="color:#66d9ef">if</span> (image.sd_isAnimated <span style="color:#f92672">||</span> ([animatedImageClass isSubclassOfClass:[UIImage <span style="color:#66d9ef">class</span>]] <span style="color:#f92672">&amp;&amp;</span> [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)])) {
<span style="color:#75715e">#if SD_MAC
</span><span style="color:#75715e"></span>                image <span style="color:#f92672">=</span> [[NSImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:kCGImagePropertyOrientationUp];
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>                image <span style="color:#f92672">=</span> [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation];
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>            }
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (options <span style="color:#f92672">&amp;</span> SDImageCacheMatchAnimatedImageClass) {
            <span style="color:#75715e">// Check image class matching
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">Class</span> animatedImageClass <span style="color:#f92672">=</span> image.<span style="color:#66d9ef">class</span>;
            <span style="color:#66d9ef">Class</span> desiredImageClass <span style="color:#f92672">=</span> context[SDWebImageContextAnimatedImageClass];
            <span style="color:#66d9ef">if</span> (desiredImageClass <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>[animatedImageClass isSubclassOfClass:desiredImageClass]) {
                image <span style="color:#f92672">=</span> nil;
            }
        }
    }
		
  	<span style="color:#75715e">// 如果已经获取到 image 并且没有设置 SDImageCacheQueryMemoryData直接结束当前方法
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">// 因为只是查询了内存中的内容，并没有用到operation，所以返回的对象为nil
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">BOOL</span> shouldQueryMemoryOnly <span style="color:#f92672">=</span> (image <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(options <span style="color:#f92672">&amp;</span> SDImageCacheQueryMemoryData));
    <span style="color:#66d9ef">if</span> (shouldQueryMemoryOnly) {
        <span style="color:#66d9ef">if</span> (doneBlock) {
            doneBlock(image, nil, SDImageCacheTypeMemory);
        }
        <span style="color:#66d9ef">return</span> nil;
    }
    
    <span style="color:#75715e">// 第二步，查询磁盘缓存
</span><span style="color:#75715e"></span>    NSOperation <span style="color:#f92672">*</span>operation <span style="color:#f92672">=</span> [NSOperation new];
    <span style="color:#75715e">// Check whether we need to synchronously query disk
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 1. in-memory cache hit &amp; memoryDataSync
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2. in-memory cache miss &amp; diskDataSync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">BOOL</span> shouldQueryDiskSync <span style="color:#f92672">=</span> ((image <span style="color:#f92672">&amp;&amp;</span> options <span style="color:#f92672">&amp;</span> SDImageCacheQueryMemoryDataSync) <span style="color:#f92672">||</span>
                                (<span style="color:#f92672">!</span>image <span style="color:#f92672">&amp;&amp;</span> options <span style="color:#f92672">&amp;</span> SDImageCacheQueryDiskDataSync));
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>queryDiskBlock)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span>  <span style="color:#f92672">^</span>{
        <span style="color:#66d9ef">if</span> (operation.isCancelled) {
            <span style="color:#66d9ef">if</span> (doneBlock) {
                doneBlock(nil, nil, SDImageCacheTypeNone);
            }
            <span style="color:#66d9ef">return</span>;
        }
        
      	<span style="color:#75715e">// 设计大量内存的使用，创建自动释放池有利于内存平稳释放
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">@autoreleasepool</span> {
          	<span style="color:#75715e">// 获取磁盘中的 data
</span><span style="color:#75715e"></span>            NSData <span style="color:#f92672">*</span>diskData <span style="color:#f92672">=</span> [self diskImageDataBySearchingAllPathsForKey:key];
            UIImage <span style="color:#f92672">*</span>diskImage;
            SDImageCacheType cacheType <span style="color:#f92672">=</span> SDImageCacheTypeNone;
            <span style="color:#66d9ef">if</span> (image) {
                <span style="color:#75715e">// the image is from in-memory cache, but need image data
</span><span style="color:#75715e"></span>                diskImage <span style="color:#f92672">=</span> image;
                cacheType <span style="color:#f92672">=</span> SDImageCacheTypeMemory;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (diskData) {
                cacheType <span style="color:#f92672">=</span> SDImageCacheTypeDisk;
                <span style="color:#75715e">// 解码
</span><span style="color:#75715e"></span>                diskImage <span style="color:#f92672">=</span> [self diskImageForKey:key data:diskData options:options context:context];
              	<span style="color:#75715e">// 设置中需要在内存中保留一份
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (diskImage <span style="color:#f92672">&amp;&amp;</span> self.config.shouldCacheImagesInMemory) {
                    NSUInteger cost <span style="color:#f92672">=</span> diskImage.sd_memoryCost;
                    [self.memoryCache setObject:diskImage forKey:key cost:cost];
                }
            }
            
            <span style="color:#66d9ef">if</span> (doneBlock) {
                <span style="color:#66d9ef">if</span> (shouldQueryDiskSync) {
                    doneBlock(diskImage, diskData, cacheType);
                } <span style="color:#66d9ef">else</span> {
                    dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                        doneBlock(diskImage, diskData, cacheType);
                    });
                }
            }
        }
    };
    
    <span style="color:#75715e">// 使用GCD向队列添加任务，根据设置的sync判断同步或异步
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (shouldQueryDiskSync) {
        dispatch_sync(self.ioQueue, queryDiskBlock);
    } <span style="color:#66d9ef">else</span> {
        dispatch_async(self.ioQueue, queryDiskBlock);
    }
    
    <span style="color:#66d9ef">return</span> operation;
}
</code></pre></div><p>SD 的 image 和缓存处理到这里就差不多，下面我们可以看看处理内存释放的地方，内存释放有两种</p>
<ul>
<li>内存释放</li>
<li>磁盘释放</li>
</ul>
<p>我们可以先看 SDMemoryCache</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">commonInit</span> {
    SDImageCacheConfig <span style="color:#f92672">*</span>config <span style="color:#f92672">=</span> self.config;
    self.totalCostLimit <span style="color:#f92672">=</span> config.maxMemoryCost;
    self.countLimit <span style="color:#f92672">=</span> config.maxMemoryCount;
    
    [config addObserver:self forKeyPath:NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(maxMemoryCost)) options:<span style="color:#ae81ff">0</span> context:SDMemoryCacheContext];
    [config addObserver:self forKeyPath:NSStringFromSelector(<span style="color:#66d9ef">@selector</span>(maxMemoryCount)) options:<span style="color:#ae81ff">0</span> context:SDMemoryCacheContext];
    
<span style="color:#75715e">#if SD_UIKIT
</span><span style="color:#75715e"></span>    self.weakCache <span style="color:#f92672">=</span> [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:<span style="color:#ae81ff">0</span>];
    self.weakCacheLock <span style="color:#f92672">=</span> dispatch_semaphore_create(<span style="color:#ae81ff">1</span>);
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:<span style="color:#66d9ef">@selector</span>(didReceiveMemoryWarning:)
                                                 name:UIApplicationDidReceiveMemoryWarningNotification
                                               object:nil];
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>}
</code></pre></div><p>由于 SDMemoryCache 是继承 NSCache 这个类的，它也具备在内存紧张的时候自动释放内存，有关于 这部分可以看关于<a href="https://k.felixplus.top/nscache/">NSCache</a> 这里要注意的是 SDMemoryCache 重写了父类的一些方法，相当于扩展了一下 NSCache，增加了一个 weakCache 对象</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setObject:</span>(<span style="color:#66d9ef">id</span>)obj <span style="color:#a6e22e">forKey:</span>(<span style="color:#66d9ef">id</span>)key <span style="color:#a6e22e">cost:</span>(NSUInteger)g {
    [super setObject:obj forKey:key cost:g];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self.config.shouldUseWeakMemoryCache) {
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&amp;&amp;</span> obj) {
        <span style="color:#75715e">// Store weak cache
</span><span style="color:#75715e"></span>        SD_LOCK(self.weakCacheLock);
        [self.weakCache setObject:obj forKey:key];
        SD_UNLOCK(self.weakCacheLock);
    }
}

- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">objectForKey:</span>(<span style="color:#66d9ef">id</span>)key {
    <span style="color:#66d9ef">id</span> obj <span style="color:#f92672">=</span> [super objectForKey:key];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self.config.shouldUseWeakMemoryCache) {
        <span style="color:#66d9ef">return</span> obj;
    }
    <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>obj) {
        <span style="color:#75715e">// Check weak cache
</span><span style="color:#75715e"></span>        SD_LOCK(self.weakCacheLock);
        obj <span style="color:#f92672">=</span> [self.weakCache objectForKey:key];
        SD_UNLOCK(self.weakCacheLock);
        <span style="color:#66d9ef">if</span> (obj) {
            <span style="color:#75715e">// Sync cache
</span><span style="color:#75715e"></span>            NSUInteger cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">if</span> ([obj isKindOfClass:[UIImage <span style="color:#66d9ef">class</span>]]) {
                cost <span style="color:#f92672">=</span> [(UIImage <span style="color:#f92672">*</span>)obj sd_memoryCost];
            }
            [super setObject:obj forKey:key cost:cost];
        }
    }
    <span style="color:#66d9ef">return</span> obj;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">removeObjectForKey:</span>(<span style="color:#66d9ef">id</span>)key {
    [super removeObjectForKey:key];
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>self.config.shouldUseWeakMemoryCache) {
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">if</span> (key) {
        <span style="color:#75715e">// Remove weak cache
</span><span style="color:#75715e"></span>        SD_LOCK(self.weakCacheLock);
        [self.weakCache removeObjectForKey:key];
        SD_UNLOCK(self.weakCacheLock);
    }
}
</code></pre></div><p>关于磁盘缓存，可以回看 SDImageCache ，其中 SDImageCache 监听了应用进入后台的通知，在进入后台时会调用这个方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">deleteOldFilesWithCompletionBlock:</span>(nullable SDWebImageNoParamsBlock)completionBlock {
    dispatch_async(self.ioQueue, <span style="color:#f92672">^</span>{
        [self.diskCache removeExpiredData];
        <span style="color:#66d9ef">if</span> (completionBlock) {
            dispatch_async(dispatch_get_main_queue(), <span style="color:#f92672">^</span>{
                completionBlock();
            });
        }
    });
}

<span style="color:#75715e">#pragma mark - UIApplicationWillTerminateNotification
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#if SD_UIKIT || SD_MAC
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">applicationWillTerminate:</span>(NSNotification <span style="color:#f92672">*</span>)notification {
    [self deleteOldFilesWithCompletionBlock:nil];
}
<span style="color:#75715e">#endif
</span></code></pre></div><p>至此，SD的整体流程大致就分析完了，希望能对各位理解网络缓存图片的流程理解提供一点帮助</p>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>


    
        <a href="http://example.org/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="http://example.org/posts">Posts</a>
        
    
    
        
            &#183; 
            <a href="http://example.org/tags/objc/">Arithmetic</a>
        
            &#183; 
            <a href="http://example.org/about">Who is Cb7d?</a>
        
    
    &#183; 
    <a href="http://example.org/">
        main
    </a>

</p>
</div>


        <div class="section footer">Cb7d &lsquo;s blog. <a href="mailto:cb7d23@gmail.com">cb7d23@gmail.com</a></div>
    </div>
</body>

</html>