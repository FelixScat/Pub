<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tips on Cb7d</title>
    <link>http://example.org/tags/tips/</link>
    <description>Recent content in tips on Cb7d</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2020</copyright>
    <lastBuildDate>Sat, 13 Jul 2019 10:46:42 +0800</lastBuildDate>
    
	<atom:link href="http://example.org/tags/tips/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NSTimer 的一个小问题</title>
      <link>http://example.org/posts/timer/</link>
      <pubDate>Sat, 13 Jul 2019 10:46:42 +0800</pubDate>
      
      <guid>http://example.org/posts/timer/</guid>
      <description>Timer 的一个小问题  开发过程中我们必不可少的需要接触定时器，在iOS中，常用的定时器有以下几种：
  GCD Timer CADisplayLink NSTimer  这里我们主要来看下 NSTimer 的一个问题
#import &amp;#34;ViewController.h&amp;#34;  @interface ViewController () @property (nonatomic, strong) NSTimer *t; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; } - (void)startTImer { _t = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(someBussiness) userInfo:nil repeats:true]; [[NSRunLoop currentRunLoop] addTimer:_t forMode:NSRunLoopCommonModes]; } - (void)someBussiness { NSLog(@&amp;#34;timer triggered&amp;#34;); } - (void)dealloc { NSLog(@&amp;#34;Controller dealloc&amp;#34;); if (self.t) { [self.t invalidate]; } } - (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event { if (self.</description>
    </item>
    
    <item>
      <title>重构是什么？如何重构？</title>
      <link>http://example.org/posts/refactor/</link>
      <pubDate>Thu, 23 May 2019 10:46:42 +0800</pubDate>
      
      <guid>http://example.org/posts/refactor/</guid>
      <description>About Refactor 很多项目在最开始的时候可能会希望快速迭代，这个时候由于考虑不到位、不周全，很多的项目在后面可能会面临无法继续维护，增加新特性的问题。
何时重构 发现问题的时候就是重构的最佳时机
嘴里总是会说，下个版本重构，下个版本重构，这就像是 明日复明日，明日何其多 ，不然真的到了无法维护的地步再去重构那将面临的巨大工作量，代价将会是巨大的
怎样重构 在重构的时候我们可能同时还有很多项目会并行进行，这个时候如何重构就要因情况而定了
 你的TeamLeader专门安排了重构项目（短期小规模） 你需要大规模重构切时间跨度较大 你需要在项目中完成重构并且时间有限  针对以上的不同情况我们有不同的重构方案，
在短期小规模并且专门进行重构的时候我们可以直接将需要旧代码重写掉，这个时候一定要注意，重构的前提是测试，你需要将测试用例完善后再开始写代码，千万不要前后颠倒
那么在时间有限的项目或事大规模的重构中我们应该如何做呢，这个时候就会有两种方式
 将所有重构放在新的版本控制分支上，全部更新完成后合并回主分支 一边重构一边开发，同时进行在项目分支上  全部做完再合并回主分支会有一个缺点，当你完成全部工作合并回主干分支的时候可能会遇到海量的冲突，会很烦躁，如果你平时持续的合并也可能会遇到各种冲突，那么最佳解决办法其实就是第二种，开发的同时进行重构。
怎样能够在开发的同时重构呢，要知道，完成整个重构项目可能会经历多个项目才能完成，这里就可以用设计模式中的桥接模式进行处理
比如我们有以下用来记录日志的工具
struct CommonLog { func log(str: String) { print(str) } } 在重构的时候则可以这样改
protocol logable { func log(str: String) -&amp;gt; Void } struct NewLog: logable { func log(str: String) { print(&amp;#34;new:&amp;#34; + str) } } struct CommonLog { let newLog: logable? func log(str: String) { #if !DEBUG print(str) #endif #if DEBUG if let newLog = newLog { newLog.</description>
    </item>
    
  </channel>
</rss>