<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码阅读 on Cb7d</title>
    <link>http://example.org/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
    <description>Recent content in 源码阅读 on Cb7d</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2020</copyright>
    <lastBuildDate>Wed, 19 Feb 2020 10:46:42 +0800</lastBuildDate>
    
	<atom:link href="http://example.org/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AFNetworking 你真的了解吗</title>
      <link>http://example.org/posts/afnetworking/</link>
      <pubDate>Wed, 19 Feb 2020 10:46:42 +0800</pubDate>
      
      <guid>http://example.org/posts/afnetworking/</guid>
      <description>AFN . ├── AFCompatibilityMacros.h ├── AFHTTPSessionManager.h ├── AFHTTPSessionManager.m ├── AFNetworkReachabilityManager.h ├── AFNetworkReachabilityManager.m ├── AFNetworking.h ├── AFSecurityPolicy.h ├── AFSecurityPolicy.m ├── AFURLRequestSerialization.h ├── AFURLRequestSerialization.m ├── AFURLResponseSerialization.h ├── AFURLResponseSerialization.m ├── AFURLSessionManager.h └── AFURLSessionManager.m Why AFN 大多项目中我们都会使用网络请求去和服务端进行交互，而对于iOS开发者而言，最广为人知的网络请求框架莫过于 AFNetworking 了，那么大家有没有想过为什么广大的开发者选择了它，它对比iOS原生的网络请求有什么区别呢，下面我会总结下自己对于 AFN 的看法和体会，也希望能对一样学习的小伙伴提供一些帮助
AFN 解析 基本使用 GET
- (void)sendRequest { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSURLSessionDataTask *task = [manager GET:@&amp;#34;http://httpbin.org/get&amp;#34; parameters:@{@&amp;#34;arg1&amp;#34;:@(100), @&amp;#34;arg2&amp;#34;: @{@&amp;#34;foo&amp;#34;:@&amp;#34;bar&amp;#34;}} progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; } POST</description>
    </item>
    
    <item>
      <title>Aspects 面向切面编程</title>
      <link>http://example.org/posts/aspects/</link>
      <pubDate>Wed, 19 Feb 2020 10:46:42 +0800</pubDate>
      
      <guid>http://example.org/posts/aspects/</guid>
      <description>Aspects 本文示例工程
什么是AOP？
面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以‘set*’开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。
在开发过程中我们总会遇到某种需求，需要对我们业务内部的所有状态进行统一管理，比如对点击事件，用户进入的页面等进行埋点处理，对于这种需求我们一般会想到利用 Runtime 的消息转发功能实现这种需求，对这块不熟悉的同学可以看这篇，下面我们来看下 Aspects 是如何设计的
使用方式 先看下接口里面的方法
@interface NSObject (Aspects) /// Adds a block of code before/instead/after the current `selector` for a specific class. /// /// @param block Aspects replicates the type signature of the method being hooked. /// The first parameter will be `id&amp;lt;AspectInfo&amp;gt;`, followed by all parameters of the method. /// These parameters are optional and will be filled to match the block signature.</description>
    </item>
    
    <item>
      <title>SDWebimage 的高明之处</title>
      <link>http://example.org/posts/sdwebimage/</link>
      <pubDate>Wed, 19 Feb 2020 10:46:42 +0800</pubDate>
      
      <guid>http://example.org/posts/sdwebimage/</guid>
      <description>SDWebImage 在上古时代，最粗暴的为imageView添加图片的姿势是这样的
NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&amp;#34;https://github.com/FelixScat/Pub/blob/master/image/retainCircle.png?raw=true&amp;#34;]]; [self.imgV setImage:[UIImage imageWithData:data]]; 而目前大部分iOS应用中都使用了网络图片缓存框架，使用最多的莫过于 SDWebImage 了，这篇主要从源码角度分析下，因为源码比较多，下文例子中可能会进行一些删减
调用接口 使用 SD 发起图片请求仅仅需要一行代码
[self.imgV sd_setImageWithURL:[NSURL URLWithString:@&amp;#34;https://cn.bing.com/sa/simg/hpc26.png&amp;#34;]]; 我们可以追踪进文件 UIImageView+WebCache 里面
- (void)sd_setImageWithURL:(nullable NSURL *)url { [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil]; } - (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder { [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil]; } - (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options { [self sd_setImageWithURL:url placeholderImage:placeholder options:options progress:nil completed:nil]; } ... 这里发现这些方法最终都会调用同一个方法，相当于便利方法，为不同的需求提供多种接口，下面最终的方法是这样的
- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock { [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) { if (completedBlock) { completedBlock(image, error, cacheType, imageURL); } }]; } 这里调用的sd_internalSetImageWithURL方法是 UIView的分类，作者应该是希望和UIButton复用一份代码，所以把核心逻辑作为了UIView的分类</description>
    </item>
    
  </channel>
</rss>